## **⼆叉树的遍历⽅式**

[「代码随想录」刷题攻略 (qq.com)](https://mp.weixin.qq.com/s/zLyWzB0erh3cdinESvisBQ)

## 深度优先遍历

### 	前序遍历（递归法，迭代法）	

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* cur, vector<int>& res){
        if(!cur) return;
        res.push_back(cur -> val);
        traversal(cur->left, res);
        traversal(cur->right, res);
    }
};
```

```c++
//前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放⼊栈中，然后将右孩⼦加⼊栈，再加⼊左孩⼦(保证出栈的时候才是中左右的顺序)
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if(!root) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();// 中
            st.pop();
            res.push_back(node->val);
            if(node->right) st.push(node->right);// 右（空节点不⼊栈）
            if(node->left)  st.push(node->left); // 左（空节点不⼊栈）
        }
        return res;
    }
};
```



### 	中序遍历（递归法，迭代法）

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* cur, vector<int>& res){
        if(!cur) return;
        traversal(cur->left, res);
        res.push_back(cur->val);
        traversal(cur->right, res);
    }
};
```

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        //在使⽤迭代法写中序遍历，就需要借⽤指针的遍历来帮助访问节点，栈则⽤来处理节点上的元素
        auto cur = root;
        while(!st.empty() || cur){
            if(cur){                // 指针来访问节点，访问到最底层
                st.push(cur);       // 将访问的节点放进栈
                cur = cur->left;             // 左
            }
            else{
                // 从栈⾥弹出的数据，就是要处理的数据（放进res数组⾥的数据）
                cur = st.top();
                st.pop();
                res.push_back(cur->val);    // 中
                cur = cur->right;           // 右
            }
        }
        return res;
    }
};
```

### 	后序遍历（递归法，迭代法）

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* cur, vector<int>& res){
        if(!cur) return;
        traversal(cur->left, res);
        traversal(cur->right, res);
        res.push_back(cur->val);
    }
};
```

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(!root) return res;
        st.push(root);
        //先序（中左右）---调整左右顺序--->中右左（栈）---反转--->后序（左右中）
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            res.push_back(node->val);
            if(node->left)  st.push(node->left);
            if(node->right) st.push(node->right);
            
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



## ⼴度优先遍历

### 层次遍历（迭代法）

![640](G:\desktop\work\learning\study_point\Offer\二叉树.assets\640.gif)

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            //要使⽤固定⼤⼩size，不要使⽤que.size()
            int size = que.size();//que.size是不断变化的
            vector<int> vec;
            for(int i = 0; i < size; i ++){
                auto node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right); 
            }
            res.push_back(vec);
        }
        reverse(res.begin(), res.end());//反转⼀下数组即可
        return res;
    }
};
```

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                // 将每⼀层的最后元素放⼊result数组中
                if(i == size -1) res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
        }          
        return res;
    }
};
```

### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
       vector<double> res;
       queue<TreeNode*> que;
       if(root) que.push(root);
       while(!que.empty()){
           int size = que.size();
           //每层节点平均值组成的数组
           double sum = 0;
           for(int i = 0; i < size; i ++){
               auto node = que.front();
               que.pop();
               sum += node->val;
               if(node->left)  que.push(node->left);
               if(node->right) que.push(node->right);
           }
           res.push_back(sum/size);
       }
       return res;
    }
};
```

### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;//这个孩子节点是一个vector的类型
    Node() {}
    Node(int _val) {
        val = _val;
    }
    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                vec.push_back(node->val);
                //// 将节点孩⼦加⼊队列
                for(int j = 0; j < node->children.size(); j++)
                    if(node->children[j]) que.push(node->children[j]);
            }
            res.push_back(vec);
        } 
        return res;
    }
};
```

### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```c++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            int max = INT_MIN;		// 取每⼀层的最⼤值
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                max = max > node->val ? max : node->val;
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
            res.push_back(max);		// 把最⼤值放进数组
        }    
        return res;
    }
};
```

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;
    Node() : val(0), left(NULL), right(NULL), next(NULL) {}
    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/
class Solution {
public:
    Node* connect(Node* root) {

       queue<Node*> que;
       if(root) que.push(root);
       while(!que.empty()){
           int size = que.size();
           Node* node,*prenode;
           for(int i = 0; i < size; i ++){
//在单层遍历的时候记录⼀下本层的头部节点，然后在遍历的时候让前⼀个节点指向本节点              
               if(i == 0) {
                   node = que.front();// 取出一层的头结点
                   que.pop();
                   prenode = node;
               }
               else
               {
                   node = que.front();
                   que.pop();
                   prenode->next = node;// 本层前一个节点next指向本节点
                   prenode = prenode->next;
               }
               if(node->left) que.push(node->left);
               if(node->right)que.push(node->right);
           }
           prenode->next = NULL;// 本层最后一个节点指向NUL
       }
       return root;
    }
};
```

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```c++
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node* node, *prenode;
            for(int i = 0; i < size; i ++){
                if(i == 0){
                    node = que.front(); // 取出⼀层的头结点
                    que.pop();
                    prenode = node;            
                }
                else
                {
                    node = que.front();
                    que.pop();
                    prenode->next = node;// 本层前⼀个节点next指向本节点
                    prenode = prenode->next;
                }
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
            prenode->next = NULL;// 本层最后⼀个节点指向NULL
        }
        return root;
    }
};
```

### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```



### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

![640 (1)](G:\desktop\work\learning\study_point\Offer\二叉树.assets\640 (1).gif)

```c++
//递归法
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return nullptr;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

```c++
//迭代法  深度优先遍历  （前序遍历）
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if(root) st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right); // 右
 			if(node->left) st.push(node->left); // 左
        }
        return root;
    }
};

//⼴度优先遍历
class Solution {
public:
     TreeNode* invertTree(TreeNode* root) {
         queue<TreeNode*> que;
         if (root) que.push(root);
         while (!que.empty()) {
             int size = que.size();
             for (int i = 0; i < size; i++) {
                 TreeNode* node = que.front();
                 que.pop();
                 swap(node->left, node->right); // 每个节点的处理
                 if (node->left) que.push(node->left);
                 if (node->right) que.push(node->right);
 			}
 		}
 		return root;
 	}
};
```



### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```c++
//递归法
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    bool compare(TreeNode* p, TreeNode* q){
        //// ⾸先排除空节点的情况
        if(!p || !q) return p == q;
        // 排除了空节点，再排除数值不相同的情况
        if(p->val != q->val) return false;
        // 此时就是：左右节点都不为空，且数值相同的情况
		// 此时才做递归，做下⼀层的判断	//后序遍历
        return compare(p->left, q->right) && compare(p->right, q->left);
    }
};
```

```c++
//迭代法 
//本质是判断两个树是否是相互翻转的，其实已经不是所谓⼆叉树遍历的前中后序的关
//可以使⽤队列来⽐较两个树（根节点的左右⼦树）是否相互翻转
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> que;
        if(!root) return true;
        que.push(root->left); // 将左⼦树头结点加⼊队列
 		que.push(root->right); // 将右⼦树头结点加⼊队列
        while(!que.empty()){	// 接下来就要判断这这两个树是否相互翻转
            auto leftnode = que.front();que.pop();
            auto rightnode= que.front();que.pop();
            if(!leftnode && !rightnode) continue;// 左节点为空、右节点为空，说明是对称的
            // 左右⼀个节点不为空，或者都不为空但数值不相同，返回false
            if(!leftnode || !rightnode || leftnode->val != rightnode->val) return false;
            que.push(leftnode->left); que.push(rightnode->right);
            que.push(leftnode->right);que.push(rightnode->left);;
        }
        return true;
    }
};
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```c++
//递归法
//其实是求的根节点的⾼度，⽽根节点的⾼度就是这颗树的最⼤深度
//要后序遍历（左右中），因为要通过递归函数的返回值做计算树的⾼度
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
//如果真正求取⼆叉树的最⼤深度
class Solution {
public:
     int result;
     void getDepth(TreeNode* node, int depth) {
         result = depth > result ? depth : result; // 中
         if (node->left == NULL && node->right == NULL) return ;
         if (node->left) { // 左
             //depth++; // 深度+1
 			 //getDepth(node->left, depth);
 			 //depth--; // 回溯，深度-1
             getDepth(node->left, depth + 1);
 		 }
 		 if (node->right) { // 右
 			 getDepth(node->right, depth + 1);
 		 }
 		 return ;
	 }
 	 int maxDepth(TreeNode* root) {
         result = 0;
         if (root == 0) return result;
         getDepth(root, 1);
         return result;
 	 }
};
//迭代法 最⼤的深度就是⼆叉树的层数
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int depth = 0;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth ++;// 每层   深度
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
        }
        return depth;
    }
};
```

### [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

```c++
//递归法
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;
    Node() {}
    Node(int _val) {
        val = _val;
    }
    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int depth = 0;
        for(int i = 0; i < root->children.size(); i++){
            depth = max(depth, maxDepth(root->children[i]));//左右儿子  儿子
        }
        return depth + 1;
    }
};
//层序遍历
class Solution {
public:
    int maxDepth(Node* root) {
        int depth = 0;
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            depth ++;
            int size = que.size();
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                for(int j = 0; j < node->children.size(); j++)
                    if(node->children[j]) que.push(node->children[j]);
            }
        }
        return depth;
    }
};
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**最⼩深度是从根节点到最近叶⼦节点的最短路径上的节点数量**

```c++
//遍历的顺序为后序（左右中），
//可以看出：求⼆叉树的最⼩深度和求⼆叉树的最⼤深度的差别主要在于处理左右孩⼦不为空的逻辑。
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left && root->right) return 1 + minDepth(root->right);
        if(!root->right&& root->left) return 1 +minDepth(root->left);
        //如果左右⼦树都不为空 返回左右⼦树深度最⼩值 + 1
        return 1 + min(minDepth(root->left), minDepth(root->right));
        
    }
};

//迭代法 只有当左右孩⼦都为空的时候，才说明遍历的最低点了。如果其中⼀个孩⼦为空则不是最低点
class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            depth ++;
            int size = que.size();
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                if(node->left)  que.push(node->left);
                if(node->right) que.push(node->right);
                // 当左右孩⼦都为空的时候，说明是最低点的⼀层了，退出
                if(!node->left && !node->right) return depth;
            }
        }
        return depth;
    }
};
```

## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```c++
//遍历的顺序为后序（左右中）
class Solution {
public:
    int countNodes(TreeNode* root) {
           if(!root) return 0;
       		//int leftNum = getNodesNum(cur->left); // 左
			//int rightNum = getNodesNum(cur->right); // 右
 			//int treeNum = leftNum + rightNum + 1; // 中
           return 1 + countNodes(root->left) + countNodes(root->right); 
    }
};
//迭代法
class Solution {
public:
    int countNodes(TreeNode* root) {
        int count = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size =que.size();
            for(int i = 0; i < size; i++){
                auto node = que.front();
                que.pop();
                count ++; // 记录节点数ᰁ
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
        }
        return count;
    }
};
```

```c++
/*
完全⼆叉树只有两种情况，
	情况⼀：就是满⼆叉树，
	情况⼆：最后⼀层叶⼦节点没有满。
对于情况⼀，可以直接⽤ 2^树深度 - 1 来计算，注意这⾥根节点深度为1。
对于情况⼆，分别递归左孩⼦，和右孩⼦，递归到某⼀深度⼀定会有左孩⼦或者右孩⼦为满⼆叉树，然后依然可以
按照情况1来计算。
*/
//如果整个树不是满⼆叉树，就递归其左右孩⼦，直到遇到满⼆叉树为⽌，⽤公式计算这个⼦树（满⼆叉树）的节点数量
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        auto leftnode = root->left;
        auto rightnode= root->right;
        int leftdepth = 0, rightdepth = 0; // 这⾥初始为0是有⽬的的，为了下⾯求指数⽅便
        while(leftnode){ // 求左⼦树深度
            leftdepth ++;
            leftnode = leftnode->left;
        }
        while(rightnode){ // 求右⼦树深度
            rightdepth ++;
            rightnode = rightnode->right;
        }
        if(leftdepth == rightdepth) 
            return (2 << rightdepth) - 1;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

- ⼆叉树节点的深度：指从根节点到该节点的最⻓简单路径边的条数。

  从上到下去查 所以需要前序遍历（中左右）

- ⼆叉树节点的⾼度：指从该节点到叶⼦节点的最⻓简单路径边的条数。

  从下到上去查，所以只能后序遍历（左右中）

```c++
//要求⽐较⾼度，必然是要后序遍历。
class Solution {
public:
    bool isBalanced(TreeNode* root) {
           if(!root) return true;
           return getDepth(root) == -1 ? false:true;
    }
    //// -1 表示已经不是平衡⼆叉树了，否则返回值是以该节点为根节点树的⾼度
    int getDepth(TreeNode* node){
        if(!node) return 0;
        int leftDepth = getDepth(node->left);
        if(leftDepth == -1) return -1;
        int rightDepth = getDepth(node->right);
        if(rightDepth == -1) return -1;
        return abs(leftDepth - rightDepth) > 1 ? -1: 1 + max(leftDepth,rightDepth);
    }
};
///2
class Solution {
public:
    bool res = true;
    int traversal(TreeNode* cur){
        if(!cur) return 0;
        int left = traversal(cur->left), right = traversal(cur->right);
        if(abs(left-right) > 1) 
            res = false;
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        traversal(root);
        return res;
    }
};
```

## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

**要求从根节点到叶⼦的路径**，所以需要前序遍历，这样才⽅便让⽗节点指向孩⼦节点，找到对应的路径

<img src="G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220417231928758.png" alt="image-20220417231928758" style="zoom:50%;" />



```c++
//递归 回溯
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<string> res;
        if(!root) return res;
        traversal(root, path, res);
        return res;
    }
    //根节点，记录每⼀条路径的path，和存放结果集的result，这⾥递归不需要返回值
    void traversal(TreeNode* cur, vector<int>& path, vector<string>& res){
        path.push_back(cur->val);
        //前序  叶子结点
        //终⽌处理逻辑
        if(!cur->left && !cur->right) { // 遇到叶⼦节点
            string sPath;
            for(int i = 0; i < path.size(); i++){// 将path⾥记录的路径转为string格式
                sPath += to_string(path[i]); // 记录 （叶⼦节点）
                if(i != path.size()-1)
                    sPath += "->";
            }
            res.push_back(sPath);// 收集⼀个路径
            return;
        }
        //单层递归 回溯 逻辑
        if(cur->left) traversal(cur->left, path, res), path.pop_back();
        if(cur->right)traversal(cur->right,path, res), path.pop_back();
    }
};

//迭代法
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> trees;// 保存树的遍历节点
        stack<string> paths;// 保存遍历路径的节点
        vector<string> res;// 保存最终路径集合
        if(!root) return res;
        trees.push(root);
        paths.push(to_string(root->val));
        while(!trees.empty()){
            auto  node = trees.top(); trees.pop();// 取出节点 中
            auto  path = paths.top(); paths.pop();// 取出该节点对应的路径
            if(!node->left && !node->right)  // 遇到叶⼦节点
                res.push_back(path);
            if(node->right){// 右
                trees.push(node->right);
                paths.push(path + "->" + to_string(node->right->val));
            }
            if(node->left){// 左
                trees.push(node->left);
                paths.push(path + "->" + to_string(node->left->val));
            }
        }
        return res;
    }
};
```

### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```c++
/*
⾸先要注意是判断左叶⼦，不是⼆叉树左侧节点，不要上来想着层序遍历。
左叶⼦的明确定义：如果左节点不为空，且左节点没有左右孩⼦，那么这个节点就是左叶⼦
*/
//递归法 递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶⼦数值之和
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        //中序处理左节点
        int min_value = 0;
        if(root->left && !root->left->left && !root->left->right)
            min_value = root->left->val;
        return min_value + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
    }
};

//迭代法 迭代法使⽤前中后序都是可以的，只要把左叶⼦节点统计出来
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if(root) st.push(root);
        int res = 0;
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            if(node->left && !node->left->left && !node->left->right)
                res += node->left->val;
            if(node->right)st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return res;
    }
};
```

### [513. 找树左下角的值!!](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```c++
//递归 在树的最后⼀⾏找到最左边的值
//如果使⽤递归法，如何判断是最后⼀⾏呢，其实就是!深度最⼤!的叶⼦节点⼀定是最后⼀⾏。
//找最左边: 可以使⽤前序遍历，这样才先优先左边搜索，然后记录深度最⼤的叶⼦节点，此时就是树的最后⼀⾏最左边的值。
class Solution {
public:
    //最⼤深度最左节点的数值
    int maxDepth = INT_MIN;
    int left_val;
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return left_val;
    }
    void traversal(TreeNode* node, int leftlen){
        
        if(!node->left && !node->right) {
            if(maxDepth < leftlen) {
                maxDepth = leftlen;  // 更新最⼤深度
                left_val = node->val;// 最⼤深度最左⾯的数值
            }
            return;
        }// 中
        if(node->left){// 左
            //leftlen++;
            //traversal(node->left, leftlen);
            //leftlen--; //回溯
            traversal(root->left, leftLen + 1); // 隐藏着回溯
        }
        if(node->right){// 右
            traversal(root->right, leftLen + 1); // 隐藏着回溯
        }
        return;
    }
};

//迭代法 只需要记录最后⼀⾏第⼀个节点的数值就可以了
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        int res = 0;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i ++){
                auto node = que.front();
                que.pop();
                if(i == 0) res = node->val; // 记录最后⼀⾏第⼀个元素
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### [112. 路径总和!!!](https://leetcode-cn.com/problems/path-sum/)

**遍历从根节点到叶⼦节点的的路径看看总和是不是⽬标和**

![image-20220417235008428](G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220417235008428.png)

```c++
//递归
//可以使⽤深度优先遍历的⽅式（本题前中后序都可以，⽆所谓，因为中节点也没有处理逻辑）来遍历⼆叉树
//如果需要搜索整颗⼆叉树，那么递归函数就不要返回值，如果要搜索其中⼀条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        return traversal(root, targetSum - root->val);
    }
    bool traversal(TreeNode* root, int count){
         // 遇到叶⼦节点，并且计数为0
        if(!count && !root->left && !root->right) return true;
        // 遇到叶⼦节点⽽没有找到合适的边，直接返回
        if(!root->left && !root->right) return false;
        //单层递归的逻辑 终⽌条件是判断叶⼦节点，所以递归的过程中就不要让空节点进⼊递归了。
        if(root->left) { // 左 （空节点不遍历）
            // 遇到叶⼦节点返回true，则直接返回true
            count -= root->left->val;
            if(traversal(root->left, count)) return true;
            count += root->left->val;
            //等同与 if (traversal(cur->left, count - cur->left->val)) return true;
        }
        if(root->right){// 右 （空节点不遍历）
            // 遇到叶⼦节点返回true，则直接返回true
            count -= root->right->val;
            if(traversal(root->right, count)) return true;
            count += root->right->val;
        }
        return false;
    }
};

//迭代 此时栈⾥⼀个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。
//⽤pair结构来存放这个栈⾥的元素
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        stack<pair<TreeNode*, int>> que;// 此时栈⾥要放的是pair<节点指针，路径数值>
        if(root) que.push(pair<TreeNode*, int>(root, root->val));
        while(!que.empty()){
            auto node = que.top();
            que.pop();
            // 如果该节点是叶⼦节点了，同时该节点的路径数值等于sum，那么就返回true
            if(!node.first->left && !node.first->right && node.second == targetSum) return true;
			// 右节点，压进去⼀个节点的时候，将该节点的路径数值也记录下来
            if(node.first->right)
                que.push(pair<TreeNode*,int>(node.first->right, node.second + node.first->right->val));
            // 左节点，压进去⼀个节点的时候，将该节点的路径数值也记录下来
            if(node.first->left) 
                que.push(pair<TreeNode*,int>(node.first->left, node.second + node.first->left->val));
        }
        return false;
    }
};
```

### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

路径总和II要遍历整个树，找到所有路径，**所以递归函数不要返回值！**

<img src="G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220417235858523.png" alt="image-20220417235858523" style="zoom:50%;" />

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return res;
        path.push_back(root->val);// 把根节点放进路径
        traversal(root, targetSum - root->val);
        return res;
    }
    void traversal(TreeNode* cur, int count){// 递归函数不需要返回值，因为我们要遍历整个树
         // 遇到了叶⼦节点切找到了和为sum的路径  终止条件
        if(!cur->left && !cur->right && !count){
            res.push_back(path);
            return;
        }
        if(!cur->left && !cur->right) return;// 遇到叶⼦节点⽽没有找到合适的边，直接返回
        if(cur->left){// 左 （空节点不遍历）
            path.push_back(cur->left->val);
            count -= cur->left->val;
            traversal(cur->left, count);// 递归
            count += cur->left->val;// 回溯
            path.pop_back();		// 回溯
        }
        if(cur->right){// 右 （空节点不遍历）
            path.push_back(cur->right->val);
            count -= cur->right->val;
            traversal(cur->right, count);
            count += cur->right->val;
            path.pop_back();
        }
        return;
    }
};
```

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

![image-20220418000345725](G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220418000345725.png)

```c++
/* ⼀层⼀层切割，递归。
第⼀步：如果数组⼤⼩为零的话，说明是空节点了。
第⼆步：如果不为空，那么取后序数组最后⼀个元素作为节点元素。
第三步：找到后序数组最后⼀个元素在中序数组的位置，作为切割点
第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，⼀定是先切中序数组）
第五步：切割后序数组，切成后序左数组和后序右数组
第六步：递归处理左区间和右区间
*/

class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(!inorder.size() || !postorder.size()) return nullptr;
        return traversal(inorder, postorder);
    }
    TreeNode* traversal(vector<int>& inorder, vector<int>& postorder){
        // 第⼀步
        if(!postorder.size()) return nullptr;
        // 第⼆步：后序遍历数组最后⼀个元素，就是当前的中间节点
        int rootval = postorder[postorder.size() - 1];
        auto root = new TreeNode(rootval);
        // 叶⼦节点
        if(postorder.size() == 1) return root;
		// 第三步：找切割点 // 找到中序遍历的切割点
        int in_index;
        for(in_index = 0; in_index < inorder.size(); in_index++){
            if(inorder[in_index] == rootval) break;
        }
        // 切割中序数组
		// 左闭右开区间：[0, Index)
        vector<int> left_in(inorder.begin(), inorder.begin() + in_index);
        // [Index + 1, end)
        vector<int> right_in(inorder.begin() + in_index + 1, inorder.end());
		// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经⽤过了
        postorder.resize(postorder.size() - 1);
        // 切割后序数组
		// 左闭右开，注意这⾥使⽤了左中序数组⼤⼩作为切割点：[0, left_In.size)
        vector<int> left_post(postorder.begin(), postorder.begin() + left_in.size());
        // [left_In.size(), end)
        vector<int> right_post(postorder.begin() + left_in.size(), postorder.end());
		// 第六步
        root->left = traversal(left_in, left_post);
        root->right= traversal(right_in,right_post);

        return root;
        
    }
};
```

```c++
//递归
class Solution {
public:
    unordered_map<int, int> pos;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = postorder.size();
        for(int i = 0; i < n; i ++)
            pos[inorder[i]] = i;//每个值在中序遍历中的位置
        return traversal(inorder, 0, n-1, postorder, 0, n-1);
    }
    TreeNode* traversal(vector<int>& inorder, int li, int ri, vector<int>& postorder, int lp, int rp){
        if(lp > rp) return nullptr;
        auto root = new TreeNode(postorder[rp]);//节点
        int k = pos[root->val] - li; //根节点在inorder位置 根节点左子树的节点数
        root->left = traversal(inorder, li, li + k - 1, postorder, lp, lp + k -1); 
        root->right= traversal(inorder, li + k + 1, ri, postorder, lp + k - 1 + 1, rp - 1);
        return root;
    }
};
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```c++
class Solution {
public:
    unordered_map<int,int> pos;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for(int i = 0; i < n; i ++){
            pos[inorder[i]] = i;
        }
        return traversal(preorder, 0, n-1, inorder, 0, n-1);
    }
    TreeNode* traversal(vector<int>& preorder, int pl, int pr, vector<int>& inorder, int il, int ir){
        if(pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        int k = pos[root->val] - il;
        root->left = traversal(preorder, pl + 1, pl + 1 + k - 1, inorder, il, il + k - 1);
        root->right= traversal(preorder, pl + 1 + k - 1 + 1, pr, inorder, il + k + 1, ir);
        return root;
    }
};
```

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

### ![640 (2)](G:\desktop\work\learning\study_point\Offer\二叉树.assets\640 (2).gif)

```c++
//构造树⼀般采⽤的是前序遍历，因为先构造中间节点，然后递归构造左⼦树和右⼦树。
//当递归遍历的时候，如果传⼊的数组⼤⼩为1，说明遍历到了叶⼦节点了。
//那么应该定义⼀个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 
//这表示⼀个数组⼤⼩是1的时候，构造了⼀个新的节点，并返回。
class Solution {
public:
    //// 在左闭右闭区间[left, right]，构造⼆叉树
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size() - 1);
    }
    TreeNode* traversal(vector<int>& nums, int left, int right){
        if(left > right) return nullptr;
        // 分割点下表：maxValueIndex
        //通过下表索引直接在原数组上操作。
        int max_val_index = left;
        for(int i = left + 1; i <= right; i ++){
            if(nums[i] > nums[max_val_index])
                max_val_index = i;
        }
        auto root = new TreeNode(nums[max_val_index]);		//左右两边

        root->left = traversal(nums, left, max_val_index - 1);
        root->right= traversal(nums, max_val_index + 1, right);
        return root;
    }
};
```

### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

![640](G:\desktop\work\learning\study_point\Offer\二叉树.assets\640-1650247381129.gif)

```c++
//本题使⽤哪种遍历都是可以的
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;// 如果t1为空，合并之后就应该是t2
        if(!root2) return root1;// 如果t2为空，合并之后就应该是t1
        //单层递归的逻辑  把两棵树的元素加到⼀起 修改了t1的数值和结构
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right= mergeTrees(root1->right,root2->right);
        return root1; 
    }
};

//迭代法  把两个树的节点同时加⼊队列进⾏⽐较。
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        queue<TreeNode*> que;
        que.push(root1);
        que.push(root2);
        while(!que.empty()){
            auto node1 = que.front(); que.pop();
            auto node2 = que.front(); que.pop();
            // 此时两个节点⼀定不为空，val相加
            node1->val += node2->val;
            
            //遍历  // 如果两棵树左节点都不为空，加⼊队列
            if (node1->left && node2->left) {
                que.push(node1->left);
                que.push(node2->left);
            }
            		// 如果两棵树右节点都不为空，加⼊队列
            if (node1->right && node2->right) {
                que.push(node1->right);
                que.push(node2->right);
            }
            
            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (!node1->left&& node2->left) 
                node1->left = node2->left;
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (!node1->right&& node2->right) 
                node1->right = node2->right;
        }
        return root1;
    }
};
```

## [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```c++
/*
⼆叉搜索树是⼀个有序树:
	若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；
	若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；
	它的左、右⼦树也分别为⼆叉搜索树
*/
//搜索到⽬标节点了，就要⽴即return了，这样才是找到节点就返回（搜索某⼀条边），如果不加return，就是遍历整棵树
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val == val) return root;
        if(root->val > val) return searchBST(root->left, val);
        if(root->val < val) return searchBST(root->right,val);
        return nullptr;
    }
};
//迭代法
//对于⼆叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的⽅向
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while(root){
            if(root->val > val) root= root->left;
            else if(root->val < val) root = root->right;
            else return root;
        }
        return nullptr;
    }
};
```

### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**验证⼆叉搜索树，就相当于变成了判断⼀个序列是不是递增的**

```c++
//中序遍历下，输出的⼆叉搜索树节点的数值是有序序列。
// 将⼆叉搜索树转换为有序数组 很直观
//⽐较的是 左⼦树所有节点⼩于中间节点，右⼦树所有节点⼤于中间节点
class Solution {
public:
    TreeNode* pre = nullptr;// ⽤来记录前⼀个节点 本身比较
    
    bool isValidBST(TreeNode* root) {
        if(!root) return true;
        //单层递归的逻辑
        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从⼩到⼤
        if(pre && pre->val >= root->val) return false;
        pre = root;//记录前⼀个节点避免 初始化最⼩值 取到最左⾯节点的数值来⽐较
        bool right = isValidBST(root->right);
        return right && left;
    }
};
 
//迭代法中序遍历
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        auto cur = root;
        TreeNode* pre = nullptr;// 记录前⼀个节点
        while(cur || !st.empty()){
            if(cur){
                st.push(cur);
                cur = cur->left;
            }
            else
            {
                cur = st.top();
                st.pop();
                //work something
                if(pre && pre->val >= cur->val) 
                    return false;
                pre = cur;//保存前一个访问的结点
                //维护
                cur = cur->right;
            }
        }
        return true;
    }
}; 
```

### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```c++
//⼆叉搜索树采⽤中序遍历，其实就是⼀个有序数组。在⼀个有序数组上求两个数最⼩差值
class Solution {
public:
    vector<int> vec;
    void traversal(TreeNode* root){
        if(!root) return;
        traversal(root->left);
        vec.push_back(root->val);
        traversal(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        if(vec.size() < 2) return 0;
        int min = INT_MAX;
        for(int i = 1; i < vec.size(); i++){
            min = std::min(min, vec[i] - vec[i - 1]);
        }
        return min;
    }
};

```

<img src="G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220418104655481.png" alt="image-20220418104655481" style="zoom:50%;" />

```c++
//递归法
class Solution {
public:
    TreeNode* pre = nullptr;
    int res = INT_MAX;
    void traversal(TreeNode* cur){
        if(!cur) return;
        traversal(cur->left);// 左
        if(pre)				 // 中
            res = min(res, cur->val - pre->val);
        pre = cur; // 记录前⼀个
        traversal(cur->right);// 右
    }
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return res;
    }
};
//迭代
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        auto cur = root;
        TreeNode* pre = nullptr;
        int res = INT_MAX;
        while(cur || !st.empty()){
            if(cur){ 			// 指针来访问节点，访问到最底层
                st.push(cur);// 将访问的节点放进栈
                cur = cur->left;// 左
            }
            else
            {
                cur = st.top();
                st.pop();
                if(pre)			// 中
                    res = min(res, cur->val - pre->val);
                pre = cur;
                cur = cur->right;// 右
            }
        }
        return res;
    }
};
```

### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```c++
/*

*/
//如果不是⼆叉搜索树，最直观的⽅法⼀定是把这个树都遍历了，⽤map统计频率，把频率排个序，最后取前⾯⾼频的元素的集合。
class Solution {
public:
    //树都遍历，⽤map统计频率
    void traversal(TreeNode* cur, unordered_map<int, int>& map){// 前序遍历
        if(!cur) return;  // map<int, int> key:元素，value:出现频率
        map[cur->val]++;	// 统计元素频率
        traversal(cur->left, map); 
        traversal(cur->right,map);
        return;
    }
    vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> map; // key:元素，value:出现频率
        vector<int> res;
        if(!root) return res;
        traversal(root, map);
        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), [](const pair<int, int>& a, const pair<int, int>& b) {return a.second > b.second;});// 给频率排个序
        res.push_back(vec[0].first);
        for(int i = 1; i < vec.size(); i++){
            // 取最⾼的放到result数组中
            if(vec[i].second == vec[0].second) 
                res.push_back(vec[i].first);
            else break;
        }
        return res;
    }
};
```

<img src="G:\desktop\work\learning\study_point\Offer\二叉树.assets\image-20220418111427288.png" alt="image-20220418111427288" style="zoom:50%;" />

**既然是搜索树，它中序遍历就是有序的**。

```c++
class Solution {
public:
    int count = 0;   // 统计频率
    int maxcount = 0;// 最⼤频率
    TreeNode* pre = nullptr;
    vector<int> res;
    //利用二叉搜索树的中序遍历有序性
    void traveral(TreeNode* cur){
        if(!cur) return;
        
        traveral(cur->left);// 左

        if(pre == nullptr)
            count = 1;
        else if(pre->val == cur->val)// 与前⼀个节点数值相同
            count ++;
        
        else count = 1;  // 与前⼀个节点数值不同  
        
        pre = cur;// 更新上⼀个节点
        //找到所有的众数
        if(maxcount == count) // 如果和最⼤值相同，放进result中
            res.push_back(cur->val);
        else if(maxcount < count){// 如果计数⼤于最⼤值频率
            maxcount = count;// 更新最⼤频率
            res.clear();// 很关键的⼀步，不要忘记清空result，之前result⾥的元素都失效 
            res.push_back(cur->val);
        }     
        
        traveral(cur->right);// 右
        return;
    }
    vector<int> findMode(TreeNode* root) {
        traveral(root);
        return res;
    }
};

//迭代
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*>st;
        auto cur = root;
        TreeNode* pre = nullptr;
        int count = 0, maxcount = 0;
        vector<int>res;
        while(cur || !st.empty()){
            if(cur){// 指针来访问节点，访问到最底层
                st.push(cur);
                cur = cur ->left;
            }
            else
            {
                cur = st.top();
                st.pop();
                
                if(pre == nullptr)
                    count = 1;
                else if(pre->val == cur->val)
                    count ++;
                else count = 1;

                if(maxcount == count)
                    res.push_back(cur->val);
                if(maxcount < count){
                    maxcount = count;// 更新最大频率
                    res.clear();     // 清空之前result
                    res.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;
            }
        }
        return res;
    }
};
```

## [236. 二叉树的最近公共祖先!!!!](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

**后序遍历就是天然的回溯过程，最先处理的⼀定是叶⼦节点**

```c++
/*
本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题依然要遍历树的所有节点
递归函数有返回值就是要遍历某⼀条边，但有返回值也要看如何处理返回值
如果递归函数有返回值，如何区分要搜索⼀条边，还是搜索整个树
搜索⼀条边的写法：
    if (递归函数(root->left)) return ;
    if (递归函数(root->right)) return ;
搜索整个树写法：
    left = 递归函数(root->left);
    right = 递归函数(root->right);
    left与right的逻辑处理;
在递归函数有返回值的情况下：
如果要搜索⼀条边，递归函数返回值不为空的时候，⽴刻返回，
如果搜索整个树，直接⽤⼀个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯
*/
/*
判断⼀个节点是节点q和节点p的公共公共祖先
如果找到⼀个节点，发现左⼦树出现结点p，右⼦树出现节点q，或者 左⼦树出现结点q，右⼦树出现节点p，那么
该节点就是节点p和q的最近公共祖先
*/
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //后序遍历 回溯
        if(root == q || root == p || !root) return root;
        auto left = lowestCommonAncestor(root->left, p, q);
        auto right= lowestCommonAncestor(root->right,p, q);
        //要利用left与right的逻辑处理  so搜索整个树写法
        if(left && right) return root;
        if(right && !left) return right;
        else if(!right && left) return left;
        else return nullptr; // (left == NULL && right == NULL)
    }
};
```

```makefile
1. 求最⼩公共祖先，需要从底向上遍历，那么⼆叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历⽅
式。
2. 在回溯的过程中，必然要遍历整颗⼆叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使⽤递归
函数的返回值（也就是代码中的left和right）做逻辑判断。
3. 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以⽤返回right传给上⼀层结果。
```

### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```c++
//判断⼀个节点的左⼦树⾥有p，右⼦树⾥有q? 其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先
//普通⼆叉树求最近公共祖先需要使⽤回溯，从底向上来查找，⼆叉搜索树就不⽤了，因为搜索树有序（相当于⾃带⽅向），那么只要从上向下遍历就可以了
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return cur;
          //这⾥没有中节点的处理逻辑     // 中
        if (cur->val > p->val && cur->val > q->val) {   // 左
            TreeNode* left = traversal(cur->left, p, q);
            if (left) {
                return left;
            }
        }
        if (cur->val < p->val && cur->val < q->val) {   //右 向右遍历（⽬标区间在右⼦树）
            TreeNode* right = traversal(cur->right, p, q);
            if (right) {
                return right;
            }
        }
        return cur;//cur节点在区间中，那么cur就是最近公共祖先
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
//迭代法
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root){
            if(root->val > p->val && root->val > q->val) 
                root = root ->left;
            else if(root->val < p->val && root->val < q->val)
                root = root->right;
            else return root;
        }
        return nullptr;
    }
};
```

### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

### ![640 (1)](G:\desktop\work\learning\study_point\Offer\二叉树.assets\640 (1)-1650268640736.gif)

```c++
/*
遍历整颗搜索树简直是对搜索树的侮辱

*/
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        if (root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};

class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        TreeNode* cur = root;
        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点
        while (cur != NULL) {
            parent = cur;
            if (cur->val > val) cur = cur->left;
            else cur = cur->right;
        }
        TreeNode* node = new TreeNode(val);
        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值
        else parent->right = node;
        return root;
    }
};
```

### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4VQiboXYq4V3j9WdH12A6ibxgAFxGZsyFZWVngIZnzicYm3lJUre3iczEXBpzCdsGpRUTaGIkmXQx5SQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
/*
五种情况：

第一种情况：没找到删除的节点，遍历到空节点直接返回了
找到删除的节点
第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。
*/
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            if (root->left == nullptr) return root->right;
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) return root->left;
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};

class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```

### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

```c++
//https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247493987&idx=2&sn=2fa68db9f5d44783b303a220b23c5c7a&scene=21#wechat_redirect
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
            return left;
        }
        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
        return root;
    }
};

class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return nullptr;

        // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭
        while (root != nullptr && (root->val < L || root->val > R)) {
            if (root->val < L) root = root->right; // 小于L往右走
            else root = root->left; // 大于R往左走
        }
        TreeNode *cur = root;
        // 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况
        while (cur != nullptr) {
            while (cur->left && cur->left->val < L) {
                cur->left = cur->left->right;
            }
            cur = cur->left;
        }
        cur = root;

        // 此时root已经在[L, R] 范围内，处理右孩子大于R的情况
        while (cur != nullptr) {
            while (cur->right && cur->right->val > R) {
                cur->right = cur->right->left;
            }
            cur = cur->right;
        }
        return root;
    }
};
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```c++
class Solution {
private:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);//左闭右闭
        return root;
    }
};
```

### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

```c++
/*
树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可
*/
class Solution {
private:
    int pre; // 记录前一个节点的数值
    void traversal(TreeNode* cur) { // 右中左遍历
        if (cur == NULL) return;
        traversal(cur->right);
        cur->val += pre;
        pre = cur->val;
        traversal(cur->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        int pre = 0;
        
        stack<TreeNode*>st;
        auto cur = root;
        while(cur||!st.empty()){
            if(cur){
                st.push(cur);
                cur=cur->right;
            }
            else{
                cur = st.top();
                st.pop();
                cur->val+=pre;
                pre = cur->val;
                cur = cur->left;
            }
        }
        return root;
    }
};
```

