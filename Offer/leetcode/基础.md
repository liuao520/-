## **数组**

```c++
二分模板一共有两个，分别适用于不同情况。
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
版本2
当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}


// 当left==right，区间[left, right]依然有效，所以用 <=  
//是不是依旧有效
```



###  [704. 二分查找](https://leetcode.cn/problems/binary-search/)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size();
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] > target) r = mid;
            else if(nums[mid] <target) l = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        vector<int>f(2, -1);
        if(!nums.size()) return f;
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if(nums[l] != target) return f;
        else {
            f[0] = l;
            int l = 0, r = nums.size() - 1;
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(nums[mid] <= target) l = mid;
                else r = mid - 1;
            }
            f[1] = l;
        }
        return f;
    }
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        vector<int>f(2, -1);
        if(!nums.size()) return f;
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if(nums[l] != target) return f;
        else {
            f[0] = l;
            int l = 0, r = nums.size() - 1;
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(nums[mid] <= target) l = mid;
                else r = mid - 1;
            }
            f[1] = l;
        }
        return f;
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```c++
class Solution {
public:
    int mySqrt(int x) {
        long long  l = 0, r = x;
        while(l < r){
            long long  mid = (l + r + 1) >> 1;//小数部分将被舍去
            if((long long)mid * mid <= x) l = mid;
            else r = mid - 1;
        }
        cout << l << " "<< r;
        return l;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 0, r = num;
        while(l <= r){
            int mid = (r + l) >> 1;
            if((long)mid * mid > num) r = mid - 1;
            else if((long)mid * mid < num) l = mid  + 1;
            else return true;
        }
        return false;
    }
};
```

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv43W2OFzic9tNsB9dGwCaYbQ1Td0CliauEJ9O31cb7bLxS9AsXN6Of0icic2rBuNBrwP9ibPsqHQEI2BTA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //快慢指针的操作
        int slow = 0;
        for(int fast = 0; fast < nums.size(); fast ++){
            if(nums[fast] != val){
                nums[slow++]  = nums[fast]; 
            }
        }
        return slow;
    }
};

```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int l = 1, r = 1;
        while(r < nums.size()){
            if(nums[r] != nums[r - 1]){
                nums[l] = nums[r];//覆盖  不等时候
                l ++;
            }
            r++;//一直走寻找下一个不等的将其覆盖
        }
        return l;
    }
};

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int slow = 1;
        for(int fast = 1; fast < nums.size(); fast++){//从第二个元素开始
            if(nums[fast] != nums[fast - 1])
                nums[slow++] =nums[fast];
        }
        return slow;
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int l = 0, r = 0;
        while(r < nums.size()){
            if(nums[r]){
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
        cout << r - l<<endl;
    }
};

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int l = 0, r = 0;
        while(r < nums.size()){
            if(nums[r]){
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
        cout << r - l<<endl;
    }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```c++
class Solution {
public:
    string rebuild(string s){
        string str;
        for(auto x:s){
            if(x != '#')
                str.push_back(x);
            else if(!str.empty())
                str.pop_back();
        }
        return str;
    }
    bool backspaceCompare(string s, string t) {
        return rebuild(s) == rebuild(t);
    }
};
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv49PTAcQFBFFQtyH6RIEERSMIU4yk8AYZ3XI8cF1wJszznjJ1etuFxu4ibvvndawdu3nxfwUpibp9kA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;
        vector<int> res(k + 1, 0);
        int i = 0, j = k;
        while(i <= j){// 注意这里要i <= j，因为最后要处理两个元素
            if(nums[i] * nums[i] < nums[j] * nums[j]){
                res[k--] = nums[j] * nums[j];
                j--;
            }
            else{
                res[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return res;
    }
};
```

### [209. 长度最小的子数组-划窗](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6Dh6cLPrfmXOctLPWibfcWd4gzEh6DCeqpTNtAzEBtzpxf4JZfBOMnt7xEWYj5QJp22uzfUMYkxaQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = 0;
        int cout = INT_MAX;
        for(int i = 0; i < nums.size(); i++){
            int sum = 0;
            for(int j = i; j < nums.size(); j++){
                sum += nums[j];
                if(sum >= target){
                    len = j - i + 1;
                    cout = cout < len ? cout:len;
                    break;
                }
            }
        }
        return cout == INT_MAX?0:cout;
    }
};

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int l = 0,  r =0;//滑动窗口起始和结束位置
        int sum = 0;
        int len = 0;
        while(r < nums.size()){
            sum += nums[r];
             //使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while(sum >= target){
                len = r - l + 1;
                res = res<len?res:len;
                sum -= nums[l];
                l++;//滑动窗口的精髓，不断变更i（子序列的起始位置）
            }
            r++;
        }
         // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return res == INT_MAX?0:res;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> map;
        int len = 0, res = 0;
        int l = 0, r = 0;
        while(r < fruits.size()){
            map[fruits[r]]++;
            len++;
            while(map.size() > 2){
                map[fruits[l]] --;
                if(!map[fruits[l]]) map.erase(fruits[l]);
                len --;
                l++;
            }
            res = res>len?res:len;
            r++;
        }
        return res;
    }
};
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();
        unordered_map<char,int>map(n);
        // 将字符串t中每个字母出现的次数统计出来，这里--可以理解为有这么多的坑要填
        for(auto x:t)   
            map[x]--;
        string res = "";
        int l = 0, r = 0, cnt = 0;
        while(r < n){
            // 利用字符s[i]去填count数组的坑
            map[s[r]] ++;
// 如果cnt等于t.length，那么说明窗口内已经包含t了，这时就要考虑移动左指针了，只有当左指针指向的字符是冗余的情况下，即count[cs[j]]>0，才能保证去掉该字符后，窗口中仍然包含t
            // 注意cnt达到字符串t的长度后，它的值就不会再变化了，因为窗口内包含t之后，就会一直包含
            if(map[s[r]] <= 0) cnt ++; //有效坑位
// 如果cnt等于ct.length，那么说明窗口内已经包含t了，这时就要考虑移动左指针了，只有当左指针指向的字符是冗余的情况下，即count[cs[j]]>0，才能保证去掉该字符后，窗口中仍然包含t
// 注意cnt达到字符串t的长度后，它的值就不会再变化了，因为窗口内包含t之后，就会一直包含
            while(cnt == m && map[s[l]] > 0){
                map[s[l]]--;
                l++;
            }
            // 当窗口内包含t后，计算此时窗口内字符串的长度，更新res
            if(cnt == m){
                if(res == "" || res.size() > r - l + 1)
                    res = s.substr(l, r - l  +1);
            }
            r++;
        }
        return res;
    }
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>res(n, vector<int>(n));
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y =0, d = 1;
        for(int i = 1; i <= n * n; i++){
            res[x][y] = i;
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b < 0 || b>=n || res[a][b]){ //已经访问过此位置
                d = (d + 1) % 4; // 顺时针旋转至下一个方向
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n = matrix.size(), m = matrix[0].size();
        if(!n) return res;

        vector<vector<bool>>st(n, vector<bool>(m, false));
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;
        for(int i = 0; i < n * m; i ++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b < 0 || b >= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
```

### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int n = matrix.size();//这里问题很大  哈哈哈哈哈
        if(!n) return res;
        int m = matrix[0].size();
        vector<vector<bool>> st(n, vector<bool>(m, false));

        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;

        for(int i = 0; i < n * m; i++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
             
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b <0 || b >= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;

    }
};
```

## **链表**

#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        auto dummynode = new ListNode(0);
        dummynode->next = head;
        auto cur = dummynode;
        while(cur->next){
            if(cur->next->val == val){
                auto tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
            else 
                cur = cur->next;
        }
        head = dummynode->next;
        delete dummynode;
        return head;
    }
};
//定义dummyHead的时候，不定义指针，而是定义实体
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummyHead; // 设置一个虚拟头结点
        dummyHead.next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = &dummyHead;
        while (cur->next ) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        return dummyHead.next;
    }
};
```

### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    void addAtIndex(int index, int val) {
        if (index > _size) {
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;//可以指定的  是要前一个pre 还是cur
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv7ftmCo9j6fqIwpACbibyzDaeAjalAsyVzzxgSYicicuV3TH3vzia4rANEUghDYQPdiajHNJaWvsDTBSLQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        auto cur = head;
        while(cur){
            auto  node = cur->next;
            cur->next = pre;
            pre = cur;
            cur = node;
        }
        return pre;
    }
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr, head);
    }
    ListNode* reverse(ListNode* pre, ListNode* cur){
        if(!cur) return pre;
        auto tmp = cur->next;
        cur->next = pre;
        
        return reverse(cur, tmp);
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummynode = new ListNode(0);
        dummynode->next = head;
        auto fast = dummynode;
        auto slow = dummynode;
        while(n-- && fast){
            fast = fast->next;
        }
        // fast再提前走一步，让slow指向删除节点的上一个节点(删除操作)
        fast = fast->next;
        while(fast){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummynode->next;
    }
};
```

### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode *> visited;
        ListNode *temp = headA;
        while (temp != nullptr) {
            visited.insert(temp);
            temp = temp->next;
        }
        temp = headB;
        while (temp != nullptr) {
            if (visited.count(temp)) {
                return temp;
            }
            temp = temp->next;
        }
        return nullptr;
    }
};
 

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {//为什么有如此牛逼的想法
        if(!headA || !headB)
            return nullptr;
        auto curA = headA, curB = headB;
        while(curA != curB){
            curA = curA == nullptr?headA:curA->next;
            curB = curB == nullptr?headB:curB->next;
        }
        return curB;
        
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
//假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next
        auto fast = head->next;
        auto slow = head;
        while(fast != slow){//循环条件先于循环体
            if(!fast || !fast->next) return false;
            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
    }
};

class Solution {
public:
    bool hasCycle(ListNode *head) {
       auto fast = head, slow = head;
       while(fast && fast->next){
           slow = slow->next;
           fast = fast->next->next;
           if(fast == slow)
            return true;
       } 
       return false;
    }
};
```



### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
       if(!head || !head->next) return nullptr;
       auto fast = head;
       auto slow = head;
       while(fast && fast->next){
           fast = fast->next->next;
           slow = slow->next;
           if(slow == fast){
               slow = head;
               while(fast != slow){
                   fast = fast->next;
                   slow = slow->next;
               }
               return fast;
           }
       } 
       return nullptr;
    }
};
```

## **哈希表**

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int slen = s.size(), tlen = t.size();
        if(slen != tlen) return false;
        unordered_map<char, int> map;
        for(int i = 0; i < slen; i++){
            map[s[i]]--;
        }
        for(int i = 0; i < tlen; i++){
            map[t[i]]++;
            if(map[t[i]] > 0)
                return false;
        }
        return true;
    }
};
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int>map;
        if(!magazine.size() || !ransomNote.size()) return magazine == magazine;
        for(int i = 0; i < magazine.size(); i++){
            map[magazine[i]] --;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            map[ransomNote[i]]++;
            if(map[ransomNote[i]] > 0) return false;
        }
        return true;
    }
};

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int hash[26] = {0};
        for(int i = 0; i < magazine.size(); i++){
            hash[magazine[i] - 'a']++;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            hash[ransomNote[i] - 'a']--;
            if(hash[ransomNote[i]- 'a']<0) return false;
        }
        return true;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```c++
//对于每个单词进行类型
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        //key value  标准 特定数组
        unordered_map<string, vector<string>>map;
        for(auto &str : strs){
            string key = str;
            sort(key.begin(), key.end());
            map[key].emplace_back(str);
        }
        vector<vector<string>>res;
        for(auto x :map){
            res.emplace_back(x.second);
        }
        return res;
    }
};
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```c++
//滑动窗口
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        //维护一个不变的固定滑动窗口
        vector<int>res;
        int slen = s.size(), plen = p.size();
        if(slen < plen) return res;
        vector<int>scnt(26); vector<int>pcnt(26);
        for(int i = 0; i < plen; i++){//首字母那部分
            scnt[s[i] - 'a']++;
            pcnt[p[i] - 'a']++;
        } 
        if(scnt == pcnt) res.emplace_back(0);
        for(int i = 0; i < slen - plen ; i ++){//从i+1开始匹配
            scnt[s[i] - 'a']--;//scnt[s[i - 1] - 'a']--;
            scnt[s[i + plen] - 'a']++;//scnt[s[i + plen - 1] - 'a'] ++;
            if(scnt == pcnt) res.emplace_back(i+1);
        }
        return res;
    }
};
```

### [1002. 查找共用字符!!!](https://leetcode.cn/problems/find-common-characters/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4JNjbm2r32XZEeuDbjIlx8JSBZlR7t2ExYKUCbuL24CiajLtykPxeVib81CcbXdVZAKXjj25sbQU4Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<string>res;
        if(!words.size()) return res;
        vector<int> hash(26);//字符频率
        //单个字符在所有字符串中出现次数的最小值
        vector<int> min_cnt(26, INT_MAX); 
        for(auto x:words){
            fill(hash.begin(), hash.end(), 0);
            for(char y :x){
                hash[y - 'a']++;
            }
            for(int i = 0; i < 26; i++){
                min_cnt[i] = min(min_cnt[i], hash[i]);
                cout<<min_cnt[i]<<" ";
            }
        }
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < min_cnt[i]; j ++){
                //string s(1, i + 'a'); // char -> string
                //result.push_back(s);
                res.emplace_back(1, i + 'a');// char -> string
            }
        }
        return res;
    }
};
```

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv683KTkPTQQiadqOUIy62lID6pvNOGqqpAIVWvj5ibXo0xmsqicP2icaFKQ9Lic2SCD5XWfWrZ0ACaaEpw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//unordered_set底层实现为hash，故set内不会出现重复元素
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果 vector 不能去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

```c++
class Solution {
public:
    int get_next(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {//快慢指针的形式!!!
        //跑的人一步的意思
        int slow = n;
        int fast = get_next(n);
        while(fast != 1 && slow != fast){//什么时候会在循环。
                slow = get_next(slow);
                fast = get_next(get_next(fast));
        }
        return fast == 1;
    }
};

class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = gesum(n);
            if(sum == 1) return true;
            if(set.find(sum) != set.end()) return false; //找到了
            else set.insert(sum);
            n = sum;
        }
    }
    int gesum(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
};
```

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> findNumbersWithSum(vector<int>& nums, int target) {
        unordered_set<int> res;
        for(int i = 0; i < nums.size(); i++)
            if(res.count(target-nums[i]))
                return {nums[i], target-nums[i]};
            else res.insert(nums[i]);
        return {};
    }
}; 
class Solution {
public:
    vector<int> findNumbersWithSum(vector<int>& nums, int target) 
    {
        unordered_map<int, int> hash;//创建哈希表
        for (int i = 0; i < nums.size(); ++i) {
            if(hash[target - nums[i]] == 0)//如果哈希表中没有target - nums[i]
                hash[nums[i]]++;//nums[i]出现次数加1
            else//如果哈希表中有target - nums[i]
                return {nums[i], target - nums[i]};//返回答案
        }
        return {};

    }
};  
```

### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        //为什么能有如此聪明的想法
        //分组+哈希
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int>map;
        if(!magazine.size() || !ransomNote.size()) return magazine == magazine;
        for(int i = 0; i < magazine.size(); i++){
            map[magazine[i]] --;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            map[ransomNote[i]]++;
            if(map[ransomNote[i]] > 0) return false;
        }
        return true;
    }
};

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int hash[26] = {0};
        for(int i = 0; i < magazine.size(); i++){
            hash[magazine[i] - 'a']++;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            hash[ransomNote[i] - 'a']--;
            if(hash[ransomNote[i]- 'a']<0) return false;
        }
        return true;
    }
};
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>>res;
        sort(nums.begin(), nums.end());
        //找出a+b+c=0
        for(int i = 0; i < nums.size(); i++){
            // 去重
            if(i > 0 && nums[i] == nums[i - 1])
                continue;
            
            int left = i + 1, right = nums.size() - 1;
            while(left < right){
                if(nums[i] + nums[left] + nums[right] > 0) 
                    right--;
                else if(nums[i] + nums[right] + nums[left] < 0)
                    left ++;
                else{
                    res.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    while(left <right && nums[left] == nums[left + 1]) left++;
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
};
```

### [18. 四数之和](https://leetcode.cn/problems/4sum/)

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int k = 0 ; k < nums.size(); k++){
            if(k >0 && nums[k] == nums[k - 1])
                continue;
//四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target                
            for(int i = k + 1; i < nums.size(); i++){
                if(i > k + 1 && nums[i] == nums[i - 1])
                    continue;
                
                int left = i + 1, right = nums.size() -1 ;
                while(left < right){
                    if(nums[i] + nums[k]  > target - nums[left] -nums[right])
                        right--;
                    else if(nums[i] + nums[k]< target - nums[left] - nums[right])
                        left++;
                    else{
                        res.emplace_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 去重
                        while(left<right && nums[right] == nums[right-1]) right--;
                        while(left<right && nums[left] == nums[left+1]) left++;
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
```

## **字符串**

### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i < s.size(); i += 2*k){
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if(i + k <= s.size()-1){//这个判断语句很精髓
                reverse(s.begin()+i, s.begin()+i+k);
                continue;
            }
             // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
            reverse(s.begin()+i, s.end());
        }
        return s;
    }
};
```

### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```c++
blic:
//很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作
    string replaceSpace(string s) {
         int count = 0;
         for(int i = 0; i < s.size(); i++)
            if(s[i] == ' ')
                count ++;
        int sOldsize = s.size();
        s.resize(sOldsize + count * 2);
        int sNewsize = s.size();

        for(int i = sNewsize-1, j = sOldsize-1; j < i; j--, i--){
            if(s[j] != ' ')
                s[i] = s[j];
            else{
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;

    }
};

class Solution {
public:
    string replaceSpaces(string &str) {
    string res;
    for(auto x : str){
        if(x == ' ')
            res += "%20";
        else res += x;
    }
    return res;
    }
};
```

### [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```c++
class Solution {
public:
    string reverseWords(string s) {
        string str;
        for(int i = s.size()-1; i >=0; i--){
            if(s[i] != ' '){
                str += " ";//新的单词
                string temp;
                while(i >= 0 && s[i] != ' '){
                    temp = s[i] + temp;
                    i--;
                }
                str += temp;
            }
        }
        cout << str <<endl;
        str.erase(str.begin());
        return str;
    }
};

class Solution {
public:
    string reverseWords(string s) {
        string str;
        for(int i = s.size()-1; i>=0; i--){
            int len = 0;
            while(i >= 0 && s[i] != ' ') {
                i--;
                len++;
            }
            if(len) str += s.substr(i + 1, len) + ' ';
        }
        str.erase(str.end()-1);
        return str;
    }
};
```

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5GoB1ibeXZv6ppZs6UlVGO4j4LObJKLlPgXq6Q1qy9HicD36hBB1zxCDhXgvWsKcSJDKejTxqcJ4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c++
class Solution {
public:
    //先局部反转再 整体反转
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin()+n);
        cout<<s<<endl;
        reverse(s.begin()+n, s.end());
        cout<<s<<endl;
        reverse(s.begin(),s.end());
        return s;
    }
};


class Solution {
public:
    string reverseLeftWords(string str, int k) {
        int n = str.size();
        reverse(str.begin(),str.end());
        reverse(str.begin(), str.begin()+n-k);
        reverse(str.begin() +n-k, str.end());
        return str;
    }
};
```

### [28. KMP-实现 strStr()](https://leetcode.cn/problems/implement-strstr/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDic7g5NzCsxYSy974dBcuAyLsxxRYEk1jkrvQPTOpcavwwmjvhKWVIcQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDdWZicTlr0uVCtTmNvPL1hGTwsjR04PvmOdydkbaxr8YblehvQLBOR4Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDzOrhXshr1UeRTvQY0vnHxnSicQZpFnSazWB6z4Xb0kHwGV4lnibahxGA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
//模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
//next[i] = j 包括i之前最长相等的前后缀长度 是j
//初始化 前缀表统一减一的一种实现  next[0] = j = -1;
    void get_nest(int *next, const string& s){
        //初始化
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++){
            while(j >=0 && s[i] != s[j + 1])
                j = next[j];//向前回退
            if(s[i] == s[j + 1])//找到了相同的前后缀
                j ++;
            next[i] = j;//
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;

        int next[needle.size()];
        get_nest(next, needle);

        int j = -1;
        for(int i = 0; i < haystack.size(); i ++){
            while(j >= 0 && haystack[i] != needle[j +1])
                j = next[j];
            if(haystack[i] == needle[j + 1])
                j++;
            if(j == needle.size() - 1)
                return i - needle.size() + 1; 
        }
        return -1;
    }
};
```

### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

```c++
//数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。
//最长相同前后缀的长度 j+1(next[len - 1] + 1)
class Solution {
public:
    void get_next(int* next, const string& s){
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++){
            while(j >= 0 && s[i] != s[j + 1])
                j = next[j];
            if(s[i] == s[j + 1])
                j++;
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int next[s.size()];
        get_next(next, s);
        for(auto x: next)
            cout<< x << " "; 
        int len = s.size();
 //如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。
        if(next[len - 1] + 1 != 0 && len % (len - (next[len - 1] + 1)) == 0)
            return true;
        return false;
    }
};
```

## **栈与队列**

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

 <img src="https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6aibicu5XmjicWcqwgbrRCXhdaZSGo4vRmW4Tnhmma5Z6Cicpmk47Am1ht1uf8qAxaDHbU5eOjVIfdRg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:67%;" />

```c++
class MyQueue {
public:
    stack<int> stk, cache;
    MyQueue() {

    }
    //将一个栈弹出压入另一个栈中
    void convert(stack<int> &a, stack<int>& b){
        while(!a.empty()){
            b.emplace(a.top());
            a.pop();
        }
    }
    void push(int x) {
        stk.emplace(x);
    }
    
    int pop() {
        convert(stk, cache);
        int res = cache.top();//全部转移一下  取最后那个元素
        cache.pop();
        convert(cache, stk);//然后复原回去原来的状态
        return res;
    }
    
    int peek() {
        //取最先进入stk的元素  也就是转移以后的第一个
        convert(stk, cache);
        int res = cache.top();
        convert(cache, stk);
        return res;
    }
    
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

<img src="https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6QYtsghRUccTciaMXjtJDFHib6dxnuIvt6j9OGPpJo9Bib7Rh67lCANhpykcDQ9aVdp4GbGAvhnHMwA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:67%;" />

```c++
class MyStack {
public:
    MyStack() {

    }
    queue<int> que, cache;
    void push(int x) {
        que.emplace(x);
    }
    
    int pop() {
        //将que所有元素取出来 留下最后一个元素
        int qsize = que.size();
        for(int i = 0; i < qsize - 1; i++){
            cache.emplace(que.front());
            que.pop();
        }

        int res = que.front();//留下最后一个元素是要返回的值
        que.pop();
        
        que = cache; // 再将que赋值给cache

        while(!cache.empty()){// 清空cache
            cache.pop();
        }
        return res;
    }
    
    int top() {
        return que.back();
    }
    
    bool empty() {
        return que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<int> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
};
```

### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4TwPPDSV1UsA1mNCS595kT4e4iaicribnMyr5icq28rxDVTKJaDKiawacicPBwdQP1cFXLjN9cODdpVPVQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for(auto ch:s){
            if(res.empty() || res.back() != ch)
                res.push_back(ch);
            else res.pop_back();
        }
        return res;
    }
};
```

### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4mCxur8W49qtZmumwtiax6RxExibQQUD4byjhqjr42XrV2K5zRFiaoRf2KBhdFpMPibx8PQuLzOamiaQA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                int num1 = st.top();
                st.pop();
                int num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoi(tokens[i]));
            }
        }
        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
```

### [239. 单调队列-滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4mCxur8W49qtZmumwtiax6R0axb2Svoib5fzy1ibMlLRFslLlq9TSG84soSCoicvH5jmlQUpKwHiaXZ6A/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
//单调队列
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int>res;
        deque<int>q;
        for(int i = 0; i < nums.size(); i++){
            // 如果当前元素的下标与队头元素下标的距离超过窗口大小
            while(q.size() && i - q.front() >= k)
                q.pop_front();//头出列
            // 队列q不为空且 队列尾部比当前元素值小
            while(q.size() && nums[q.back()] < nums[i])
                q.pop_back();//一直踢人 保持维护队列单调性 和首元素最大
            q.push_back(i);
//枚举到第k-1个元素后，每次枚举一个新的i都要找一次答案
            if(i >= k - 1)//取队头作为窗口最大元素 输入次数大于窗口值
                res.push_back(nums[q.front()]);
        }
        return res;
    }
}
//优先队列
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>>que;
        for(int i = 0; i < k; i++){
            que.emplace(nums[i], i);
        }
        vector<int> res = {que.top().first};
        for(int i = k; i < nums.size(); i++){
            que.emplace(nums[i],i);
//这个值的位置出现在滑动窗口左边界的左侧 不在滑动窗口
            while(que.top().second <= i - k)
                que.pop();
            res.emplace_back(que.top().first);
        }
        return res;
    }
};
```

### [135. 最大子序和 - AcWing题库](https://www.acwing.com/problem/content/description/137/)

```c++
#include <iostream>
#include <cstring>
#include<climits>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 3e5 + 10;
int n, m;
LL s[N], que[N];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &s[i]), s[i] += s[i - 1];

    LL res = INT_MIN;
    int hh = 1, tt = 1; que[1] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        while (hh <= tt && i - que[hh] > m) hh ++ ;
        res = max(res, s[i] - s[que[hh]]);
        while (hh <= tt && s[que[tt]] >= s[i]) tt -- ;
        que[ ++ tt] = i;
    }
    printf("%lld\n", res);
    return 0;
}
```

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int>map;
        for(int i = 0; i < nums.size(); i++){
            map[nums[i]]++;
        }
        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), [](const pair<int, int>& a, const pair<int, int>& b) {return a.second > b.second;});
        
        vector<int>res;
        for(int i = 0; i < k; i++){
            res.push_back(vec[i].first);
        }
        return res;
    }
};
//优先队列
class Solution {
public:
    static bool cmp(pair<int, int>& m, pair<int, int>& n) {
        return m.second > n.second;
    }
    // struct myComparison{
    //     bool operator()(pair<int,int>&p1,pair<int,int>&p2){
    //         return p1.second>p2.second;//小顶堆是大于号
    //     }
    // };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>map;//两个int分别是元素和出现的次数
        for(auto& c:nums){
            map[c]++;
        }
// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp); 
// priority_queue<pair<int,int>,vector<pair<int,int>>,myComparison> q; 
        for(auto& a:map){
            q.push(a);
            if(q.size()>k){
               q.pop(); 
            }
        }
        //将结果导出
        vector<int>res;
        while(!q.empty()){
            res.emplace_back(q.top().first);
            q.pop();
        }
        return res;
    }
};
```

## **回溯法**

```c++
**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### [77. 组合](https://leetcode.cn/problems/combinations/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5SBsnFmqibXvBHKstibeks0YUzF9lMF5Zt4ZZ4RibVpeWkYWgB8yR5clS77Ds6lXzIQAbtTicaicSBwfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
class Solution {
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
 //搜索起点有上界 后面无意义
//搜索起点的上界(最大起点) + 接下来要选择的元素个数 - 1 = n
//i + (k - path.size()) - 1 = n
        for (int i = startIndex; i <= n; i++) {   //横 n的范围
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归	//纵 i+1
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6vKujia98Cyl8icF4GEOLJxQ1htrhHXMRicN3S2U3ClLGAia2X7g5nFdZNAFGec8gJ5kP0K7S6bCmung/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    // targetSum：目标和，也就是题目中的n。
    // k：题目中要求k个数的集合。
    // sum：已经收集的元素的总和，也就是path里元素的总和。
    // startIndex：下一层for循环搜索的起始位置。
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        if (path.size() == k) {
            if (sum == targetSum) result.push_back(path);
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        for (int i = startIndex; i <= 9; i++) {
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) { 
        backtracking(n, k, 0, 1);
        return result;
    }
};
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4g9ialwsB98zmuWnyLlpiaohoHHDTWSd9h1PQ9ibjVtIlibWldpCleITDILBVEGeuEruaa3KYU1K96tg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
private:
        unordered_map<char, string> phoneMap{
            {'0', ""},
            {'1', ""},
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };
public:
    vector<string>res;
    string path;
    void backtracking(string &digits, int index){
        if(index == digits.size()){
            res.emplace_back(path);
            return;
        }
        string lettres = phoneMap[digits[index]]; // 取数字对应的字符集
        for(int i = 0; i< lettres.size(); i++){
            path.push_back(lettres[i]);
            backtracking(digits, index+1);// 递归，注意index+1，一下层要处理下一个数字了
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(!digits.size()) return res;
        backtracking(digits, 0);
        return res;
    }
};
```

### 小结

```c++
for循环横向遍历，递归纵向遍历，回溯不断调整结果集
剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6p9Y0KMzgELlibLy2weiauuDDlNKe1gt6tq0r2C1ichf344s3ZHMIYfLyMiaOic6EaBM3jXiaptNNyMEWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
/*
本题还需要startIndex来控制for循环的起始位置
对于组合问题，什么时候需要startIndex呢？
#如果是一个集合来求组合的话，就需要startIndex
#如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex
But
#如果是排列问题，又是另一套分析的套路
*/
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }
        /*
        //搞清楚从哪里面选(循环)
        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = Index; i < candidates.size() && sum + candidates[i] <= target; i++) {
        */
        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            // 不用i+1了，表示可以重复读取当前的数
            //组合没有数量要求
            //元素可无限重复选取
            backtracking(candidates, target, sum, i); 
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) { 
        
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv48aCU4UTGAaibHh1UFayia1yBvRvuXqu2Z4jnaY2fEhUoL3Ggr0zxN7vgzKBRHO7QmeBy5BO1BqeFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
本题candidates 中的每个数字在每个组合中只能使用一次。
本题数组candidates的元素是有重复的，而39.组合总和是无重复元素的数组candidates
本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合

所谓去重，其实就是使用过的元素不能重复选取
元素在同一个组合内是可以重复的,但两个组合不能相同
-->要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重
-->(树层去重的话，需要对数组排序)
*/
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            backtracking(candidates, target, sum, i + 1, used); 
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false); 
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv752l07A1icibBf67wY0GN5cOWDabGLaaOOJKXX23gIU966mkvzD94MOl6TAUAvuCl509osqRRbpfYw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
1.切割问题，有不同的切割方式
2.判断回文
切割问题类似组合问题
组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。
*/
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) { 
        backtracking(s, 0);
        return result;
    }
};
```

### [93. !!!!!复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6mT5fLDGWGROx8nmCACI1veyyNRst5JoiclawgZesPZWNO9H195g9kRFICHpvw9gMVyXqoNMltnXQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    /* // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
        段位以0为开头的数字不合法
        段位里有非正整数字符不合法
        段位如果大于255了不合法
        */
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 不能含有前导0
                return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
    vector<string> result;// 记录结果
    //需要一个变量pointNum，记录添加逗点的数量
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {//切割字符[startIndex,i]
            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
                pointNum++;
                //插入逗点之后下一个子串的起始位置为i+2
                backtracking(s, i + 2, pointNum);  
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            } else break; // 不合法，直接结束本层循环
        }
    }
public:
    vector<string> restoreIpAddresses(string s) { 
        if (s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv7icZnSOhUqwR4ibqNP3nHyktNROmSHwzzNwsWCBrtBH5tHuhg5YKSPl77r8OiapekZ77Dn8NchSoMBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
剩余集合为空的时候，就是叶子节点。
什么时候剩余集合为空呢？
就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了
其实startIndex >= nums.size()，本层for循环本来也结束了
*/ 
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size())// 终止条件可以不加//要遍历整颗树
            return;
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);//每次递归的下一层就是从i+1开始
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) { 
        backtracking(nums, 0);
        return result;
    }
};
```

### 小结

```c++
1.startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？
    如果是一个集合来求组合的话，就需要startIndex，例如：求组合问题！求组合总和！。
	如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：电话号码的字母组合
2.在求和问题中，排序之后加剪枝是常见的套路！
3.集合元素有重复,但要求不能包含重复组合
    “树枝去重”和“树层去重”
used[i - 1] == true，说明同一树支candidates[i - 1]使用过
4.切割问题
切割问题其实类似组合问题
如何模拟那些切割线
切割问题中递归如何终止
在递归循环中如何截取子串
如何判断回文 
```

### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv7DVmb1oGvLmtT7kUX5Hpmog1oKibxeeMV24Dy0UoFibor0wXU62S83iaJvoXpK8IHs9wlwWSCHam2WQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;//去重
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    } 
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { 
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
////////////////////////////////////////////////////////////////////////////////////
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        unordered_set<int> uset;		//使用set去重
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1, used);
            path.pop_back();
        }
    } 
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { 
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
```

### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6l713AIoE6ma6iaLd08CPvG6r5BqZHEZZ0PjgiaTPjejfXDtOJibnJThZXsicYM7JGian7GoU24qMltibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了
//适用于快速查找的
//终止条件  本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和求子集问题！一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归
///////////////////////////遍历树上所有的点和满足特定条件结束的区别

class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        //这里要遍历整个树,取树上节点
        if (path.size() > 1) {
            result.push_back(path);
            // 注意这里不要加return，要取树上的节点
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i < nums.size(); i++) {
            //维持path的递增和不重复
            if ((!path.empty() && nums[i] < path.back())
                    || uset.find(nums[i]) != uset.end()) {
                    continue;
            }
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) { 
        backtracking(nums, 0);
        return result;
    }
};
```

## 贪心

### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(),s.end());
        int index = 0;
        for(int i = 0; i< s.size();i++){
            if(index < g.size() && s[i]>= g[index]){
                index++;
            }
        }
        return index;
    }
};
```

### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
};
```

![image.png](https://pic.leetcode-cn.com/dd09644d01ea873cfb14a3d538c7b6b49680f5d840e22f3eef6a5e07aec78db0-image.png)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n < 2) return n;
        vector<int>up(n),down(n);
        up[0] = down[0] = 1;
        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i - 1]){
                up[i] = max(up[i - 1], down[i - 1] + 1);
                down[i] = down[i - 1];
            }
            else if (nums[i] < nums[i - 1]){
                down[i] = max(down[i - 1], up[i - 1] + 1);
                up[i] = up[i - 1];
            }
            else{
                down[i] = down[i - 1];
                up[i] = up[i - 1];
            }
        }
        return max(up[n-1], down[n-1]);
    }
};

class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return n;
        }
        int up = 1, down = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                up = max(up, down + 1);
            } else if (nums[i] < nums[i - 1]) {
                down = max(up + 1, down);
            }
        }
        return max(up, down);
    }
}; 
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6iby4YcbthvSiavmrQz0Vof28oUibXcZ460BFBvrD6nquPACzd6OmfJfsicVIVL0fbdf9Z8L4Mas08cQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)



```c++
/*
局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。
贪心的思路为局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。从而推出全局最优：选取最大“连续和”
遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和
*/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            //对于当前的num[i] 是加还是不加
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
};

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(!n) return 0;
        vector<int>f(n);
        f[0] = nums[0];
        int res = f[0];
        for(int i = 1; i < n; i ++){
            f[i] = max(f[i - 1] + nums[i], nums[i]);
            res = f[i] > res ? f[i] : res;
        } 
        return res;
    }
};
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```c++
//把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！
//需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间
class Solution {
public:
    int maxProfit(vector<int>& prices) {
//贪心的角度考虑我们每次选择贡献大于 0 的区间即能使得答案最大化
        int res = 0;
        for(int i = 1; i < prices.size(); i++){
            res += max(prices[i]-prices[i-1], 0);
        }
        return res;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6pDDdhseTveobLyAvuu6uQwibzic4VXfNYibgqI3mcoE8AbK2ObecsZibWjNmG6kBaqhzQ9NK0XBRJFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
public:
/*
关键在于可跳的覆盖范围
转化为跳跃覆盖范围究竟可不可以覆盖到终点
贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点
*/
    bool canJump(vector<int>& nums) {
         if(nums.size() == 1) return true;
         int cover = 0;
//每次移动取最大跳跃步数（得到最大的覆盖范围），且每移动一个单位，就更新最大覆盖范围。 
         for(int i = 0; i <= cover; i++){
             cover = max(cover, i + nums[i]);
             if(cover >= nums.size() - 1) return true;
         }
         return false;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv40YfANYrjM5rTqA3zx25n8EpcMf0hHuYEx5qrHXAy6buLJgicibda2zwqicVoYbH6icUymN0fHYA1zxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
/*
从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！
这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖

关键：：以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点

特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时
如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。
*/
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int curDistance = 0;    // 当前覆盖最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size(); i++) {
            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标
            if (i == curDistance) {                         // 遇到当前覆盖最远距离下标
                if (curDistance != nums.size() - 1) {       // 如果当前覆盖最远距离下标不是终点
                    ans++;                                  // 需要走下一步
                    curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）
                    if (nextDistance >= nums.size() - 1) break; // 下一步的覆盖范围已经可以达到终点，结束循环
                } else break;                               // 当前覆盖最远距离下标是集合终点，不用做ans++操作了，直接结束
            }
        }
        return ans;
    }
};
```

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv40YfANYrjM5rTqA3zx25n8ZHicEPQJwd8zHuj91oAkxbzFhicq0uIDnqrB5dlOauU09drhGhoicKk6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" /><img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv40YfANYrjM5rTqA3zx25n8TqrZFIcJSzqNicnibtCLvdz4NgA2v5kdJ3Mmy0ReWP7wXUNkhwUPKDMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

```c++
/*
针对于方法一的特殊情况，可以统一处理，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。

想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可
*/
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;    // 当前覆盖的最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖的最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标
            if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标
                curDistance = nextDistance;         // 更新当前覆盖的最远距离下标
                ans++;
            }
        }
        return ans;
    }
};
```

### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), [](int a, int b){return abs(a) > abs(b);});
        for(int i = 0 ; i < nums.size();i++){
            if(nums[i] < 0 && k > 0){
                nums[i] *= -1;
                k --;
            }
        }
        if(k & 1)nums[nums.size() - 1] *= -1;
        int res = 0;
        for(auto x : nums) res += x;
        return res;
    }
};
```

### [134. 加油站](https://leetcode.cn/problems/gas-station/)

```c++
//for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        for (int i = 0; i < cost.size(); i++) {
            int rest = gas[i] - cost[i]; // 记录剩余油量
            int index = (i + 1) % cost.size();
            while (rest > 0 && index != i) { // 模拟以i为起点行驶一圈
                rest += gas[index] - cost[index];
                index = (index + 1) % cost.size();
            }
            // 如果以i为起点跑一圈，剩余油量>=0，返回该起始位置
            if (rest >= 0 && index == i) return i;
        }
        return -1;
    }
};

/*
直接从全局进行贪心选择，情况如下：

情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的

情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。

情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点
*/
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int min = INT_MAX; // 从起点出发，油箱里的油量最小值
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if (curSum < min) {
                min = curSum;
            }
        }
        if (curSum < 0) return -1;  // 情况1
        if (min >= 0) return 0;     // 情况2
                                    // 情况3
        for (int i = gas.size() - 1; i >= 0; i--) {
            int rest = gas[i] - cost[i];
            min += rest;
            if (min >= 0) {
                return i;
            }
        }
        return -1;
    }
};

//局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置
//耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```

### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

```c++
/*
情况一：账单是5，直接收下。
情况二：账单是10，消耗一个5，增加一个10
情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5
*/
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0, twenty = 0;
        for (int bill : bills) {
            // 情况一
            if (bill == 5) five++;
            // 情况二
            if (bill == 10) {
                if (five <= 0) return false;
                ten++;
                five--;
            }
            // 情况三
            if (bill == 20) {
                // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                    twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
                } else if (five >= 3) {
                    five -= 3;
                    twenty++; // 同理，这行代码也可以删了
                } else return false;
            }
        }
        return true;
    }
};
```

### [135. 分发糖果](https://leetcode.cn/problems/candy/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv77VnicZNrhkEfUcDhzjolPlOn5h51ibRRwibuR4ZKlpzw5v9wibWRjUYrdwSukibV6icbfgz7ypK0s03Nw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼
先确定右边评分大于左边的情况（也就是从前向后遍历）
只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果
再确定左孩子大于右孩子的情况（从后向前遍历）
如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了，所以确定左孩子大于右孩子的情况一定要从后向前遍历
*/
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```

### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

```c++
/*
一定要先确定一个维度，再确定另一个维度。
如果两个维度一起考虑一定会顾此失彼
先确定一个维度，就是身高，前面的节点一定都比本节点高
按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列
局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性
全局最优：最后都做完插入操作，整个队列满足题目队列属性
*/
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(),[](const vector<int> a,const vector<int>b){return a[0]==b[0] ?a[1]<b[1]:a[0]>b[0];});
        vector<vector<int>>res;
        for(int i = 0; i < people.size(); i++){
            int position = people[i][1];
            res.insert(res.begin()+position, people[i]);
        }
        return res;
    }
};
/*
vector的底层实现也是普通数组，扩容的时候底层其实就要申请一个大小为两倍的普通数组，并且把原元素拷贝过去，释放原数组内存
*/
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(),[](const vector<int> a,const vector<int>b){return a[0]==b[0] ?a[1]<b[1]:a[0]>b[0];});
        list<vector<int>>res;
        for(int i = 0; i < people.size(); i++){
            int position = people[i][1];
            //res.insert(res.begin()+position, people[i]);
            auto it = res.begin();
            while(position--)it++;//找到插入的位置
            res.insert(it, people[i]);
        }
        return vector<vector<int>>(res.begin(),res.end());
    }
};
```

### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5jic4icLjE03g34yP8iaaUQqyrCveWgFggR16h4myicJ5JQ2pvxXxaf3FR4icXvzxr800TQrQrhb6Dn6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 80%;" />

```c++
/*
为了让气球尽可能的重叠，需要对数组进行排序
从前向后遍历遇到重叠的气球了怎么办？
如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭
寻找重复的气球，寻找重叠气球最小右边界  这是技巧
如果用remove的话 很复杂
*/
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(),[](const vector<int>&a, const vector<int>&b){return a[0] < b[0];});
        int result = 1; // points 不为空至少需要一支箭
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > points[i - 1][1]) {  // 气球i和气球i-1不挨着，注意这里不是>=
                result++; // 需要一支箭
            }
            else {  // 气球i和气球i-1挨着
                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界
            }
        }
        return result;
    }
};
```

### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

**找不重叠区**

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4CcnZt0Q9lELiaUkI2afcicL4x7h4y4mlZ66iazzZ8qVvtcyib6wdk4wtIib9L3zRrcA5PbLuZ7FGJS6A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
/*
按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。

按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。
*/
//按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了
//右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int>&a, const vector<int>&b){return a[1] < b[1];});
        int cnt = 1;// 记录非交叉区间的个数
        //从左到右记录非交叉的区间
        int end = intervals[0][1];// 记录区间分割点
        for(int i = 1; i < intervals.size(); i++){
            if(end <= intervals[i][0]){
                end = intervals[i][1];
                cnt++;
            }
        }
        return intervals.size() - cnt;
    }
};
```

### [763. ！！划分字母区间](https://leetcode.cn/problems/partition-labels/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6hB37qeLpLNqKNqibibn4TyePRIoSQ3rLUfR8s9rEdvE4hcrfB7Nkw1T2e4ymiceibDTp6wrYLymczicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        unordered_map<char,int>chmap;
        // 统计每一个字符最后出现的位置
        for(int i = 0; i < s.size(); i++){
            chmap[s[i]] = i;
        }
        vector<int>res;
        int right =0;
        int left = 0;
        for(int i = 0; i < s.size(); i++){
            // 找到字符出现的最远边界
            right = max(right, chmap[s[i]]);
            if(right == i) {
                res.emplace_back(right - left + 1);
                left = right+1;
            }
        }
        return res;
    }
};
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6MhxFViaiczr8HCw7SN51icjaj9wIWucDKTfHeSNDYeTwj1zfia2ibHUKVib7EpuTpRmCu8LIPfe3huqOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
/*
要排序，那么按照左边界排序，还是右边界排序
按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间
按照左边界从小到大排序之后，判断重复，然后模拟合并
用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组
*/
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int>&a, const vector<int>&b){return a[0]<b[0];});
        vector<vector<int>>res;
        //以第一个开始
        res.emplace_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] <= res.back()[1])// 合并区间
                res.back()[1] = max(res.back()[1], intervals[i][1]);
            else
                res.emplace_back(intervals[i]);
        }
        return res;
    }
};
```

### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

```c++
/*
局部最优：遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。
全局最优：得到小于等于N的最大单调递增的整数。
但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9。
从前后向遍历会改变已经遍历过的结果！  
*/
class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        string strNum = to_string(N);
        // flag用来标记赋值9从哪里开始
        // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {//i-1 从后往前
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```

### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```c++
/*
三种情况
情况一：当前的股票价格 prices[i] 大于 buy，那么我们直接卖出股票并且获得 prices[i]−buy 的收益，但不是全局最优
反悔操作：当前手上拥有一支买入价格为 prices[i] 的股票， buy 更新为 prices[i]。这样一来，如果下一天股票价格继续上升，我们会获得 prices[i+1]−prices[i] 的收益，加上这一天 prices[i]−buy 的收益，恰好就等于在这一天不进行任何操作，而在下一天卖出股票的收益 
情况二：//更新最低点  重新记录最小价格了。 当前的股票价格 prices[i] 加上手续费 fee 小于 buy
情况三：不作操作，保持原有状态（买入，卖出，不买不卖）  prices[i] [buy−fee,buy] 内
*/
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int buy = prices[0] + fee;
        int profit = 0;
        for(int i = 1; i < prices.size(); i++){
            if(prices[i] + fee < buy)//更新最低点
                buy = prices[i] + fee;
            else if(prices[i] > buy){
                profit += prices[i] - buy;
                buy = prices[i];//此时有利润，不卖股票
            }
            //price[i]在[buy−fee,buy]内，不做任何操作
        }
        return profit;
    }
};
```

### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

```c++
/*
二叉树从低到高推导，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少
int traversal(TreeNode* cur) {

    // 空节点，该节点有覆盖
    if (终止条件) return ;

    int left = traversal(cur->left);    // 左
    int right = traversal(cur->right);  // 右

    逻辑处理                            // 中
    return ;
}
*/
/**
0：该节点无覆盖
1：本节点有摄像头
2：本节点有覆盖
 */
class Solution {
private:
    int result;
    int traversal(TreeNode* cur) {
        // 空节点，该节点有覆盖
        if (cur == NULL) return 2;
        int left = traversal(cur->left);    // 左
        int right = traversal(cur->right);  // 右
        // 情况1
        // 左右节点都有覆盖
        if (left == 2 && right == 2) return 0;
        // 情况2
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left == 0 || right == 0) {
            result++;
            return 1;
        }
        // 情况3
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left == 1 || right == 1) return 2;

        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        // 这个 return -1 逻辑不会走到这里。
        return -1;
    }
public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        // 情况4
        if (traversal(root) == 0) { // root 无覆盖
            result++;
        }
        return result;
    }
};
```

## 动规

### 1.[斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/)

```c++
class Solution {
public:
	int fib(int N) {
		if (N <= 1) return N;
		vector<int> dp(N + 1);
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= N; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[N];
	}
};
时间复杂度： O(n)
空间复杂度： O(n)
```

### 2.[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```c++
class Solution {
public:
    //f[i]： 爬到第i层楼梯，有dp[i]种⽅法
    int climbStairs(int n) {
        if(n <= 1) return n;//防⽌空指针 下⾯直接对dp[2]操作
        vector<int> f(n + 1);
		f[1] = 1, f[2] = 2;//f[0]不好说通， 
        //只初始化f[1] = 1， f[2] = 2，然后从i = 3开始递推，符合dp[i]的定义
        for(int i = 3; i <= n; i ++)
            f[i] = f[i - 1] + f[i - 2];
        return f[n];
    }
};
时间复杂度： O(n)
空间复杂度： O(n)
```

```c++
class Solution {
public:
    //dp[i]：爬到有i个台阶的楼顶，有dp[i]种⽅法。 完全背包问题 
    int climbStairs(int n) {
        vector<int> f(n + 1);
        f[0] = 1;//排列数
        for(int j = 1; j <= n; j ++){// 遍历背包
            for(int i = 1; i <= 2; i ++){// 遍历物品
                if(j - i >= 0) 
                    f[j] += f[j - i];
        }            
        return f[n];
    }
};
```



### 3.[使⽤最⼩花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)  

```c++
class Solution {
public:
    //dp[i]的定义：到达第i个台阶所花费的最少体⼒为dp[i]。
    //（注意这⾥认为是第⼀步⼀定是要花费）
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);
        dp[0] = cost[0]，dp[1] = cost[1];//由递推公式，最终都是dp[0]dp[1]
        for(int i = 2; i < cost.size(); i ++){
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        //最后⼀步可以理解为不⽤花费，所以取倒数第⼀步，第⼆步的最少值
		return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
时间复杂度： O(n)
空间复杂度： O(n)
```

```c++
要不是第⼀步不需要花费体⼒，要不就是第最后⼀步不需要花费体⼒
class Solution {
public:
	int minCostClimbingStairs(vector<int>& cost) {
		vector<int> dp(cost.size() + 1);
		dp[0] = 0; // 默认第⼀步都是不花费体⼒的
		dp[1] = 0;
		for (int i = 2; i <= cost.size(); i++) {
            //两个途径得到dp[i]
			dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
		}
		return dp[cost.size()];
	}
};
```

### 4.[不同路径](https://leetcode-cn.com/problems/unique-paths/)

```c++
class Solution {
public:
    //dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1,0));
        //先dp[i][0]⼀定都是1，因为从(0, 0)的位置到(i, 0)的路径只有⼀条，dp[0][j]同理
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int j = 0; j < n; j++) dp[0][j] = 1;
        
        for(int i = 1; i < m; i ++)
            for(int j = 1; j < n; j ++)
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];//dp[i][j]只有这两个⽅向过来
        return dp[m - 1][n - 1];
    }
};
时间复杂度：O(m * n)
空间复杂度：O(m * n)
```

```c++
class Solution {
public:
 	int uniquePaths(int m, int n) {
        vector<int> dp(n);
         for (int i = 0; i < n; i++) dp[i] = 1;
         for (int j = 1; j < m; j++) {
            for (int i = 1; i < n; i++) {
                dp[i] += dp[i - 1];//方法个数
            }
         }
         return dp[n - 1];
 	}
};
时间复杂度：O(m * n)
空间复杂度：O(n)
```

### 5.[**不同路径** **II**](https://leetcode-cn.com/problems/unique-paths-ii/)

```c++
class Solution {
public:
    //dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
       
        for(int i = 0 ; i < m && obstacleGrid[i][0] == 0; i ++) dp[i][0] = 1;
        for(int j = 0 ; j < n && obstacleGrid[0][j] == 0; j ++) dp[0][j] = 1;

        for(int i = 1; i < m; i ++)
            for(int j = 1; j < n; j ++){
                if(!obstacleGrid[i][j])// 当(i, j)没有障碍(0)的时候，再推导dp[i][j]
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        return dp[m - 1][n - 1];
    }
};
时间复杂度O(n * m) n m 分别为obstacleGrid ⻓度和宽度 
空间复杂度O(n * m)
```

### 6:[**整数拆分**](https://leetcode-cn.com/problems/integer-break/)

```c++
class Solution {
public:
	//dp[i]：分拆数字i，可以得到的最⼤乘积为dp[i]。
    int integerBreak(int n) {
        if(n <= 1) return n;
        vector<int>f(n+1);
        f[2] = 1;//dp[0] dp[1] 就不应该初始化，没有意义的数值
        for(int i = 3; i <= n; i ++)
            for(int j = 1; j < i - 1; j ++){
//两种渠道得dp[i]:⼀个是j * (i - j) 直接相乘,⼀个是j * dp[i - j]，相当于是拆分(i - j)
                f[i] = max(f[i], max(f[i - j] * j, (i - j) * j));
            }
        return f[n];
    }
};
```

### 7:[**不同的⼆叉搜索树**](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        //dp[i]：1到i为节点组成的⼆叉搜索树的个数为dp[i]。
        dp[0] = 1;//0是有意义的  计数 空节点也是⼀颗⼆叉树，

        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= i; j ++){//子树
		//dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量]
                dp[i] += dp[i - j] * dp[j - 1];
            }
        return dp[n];
    }
};
```

## **01**背包理论基础

```c++
//dp[i][j] 表示从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少
/*
递推式：
由dp[i - 1][j]推出，即背包容量为j，⾥⾯不放物品i的最⼤价值，此时dp[i][j]就是dp[i - 1][j]
由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最⼤价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最⼤价值
初始化：
背包容量j为0的话，即dp[i][0]，⽆论是选取哪些物品，背包价值总和⼀定为0
物品i为0，存放编号0的物品的时候，各个容量的背包所能存放的最⼤价值
当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量⽐编号0的物品重量还⼩。
当j >= weight[0]是，dp[0][j] 应该是value[0]，因为背包容量放⾜够放编号0物品。

其他下标应该初始化：都会被覆盖 不涉及比较
*/
int _01beg(int m, int n){//m件物品，n容量
    vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));   
    for(int i = w[0]; i <= n; i++)
        f[0][i] =   w[0];      
    for(int i = 1; i < m; i ++)
        for(int j = 0; j <= n; j++){
            //if(j < v[i]) f[i][j] = f[i - 1][j];
            //else f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]);
            if (j - weight[i] >= 0) {
 				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
 			}
        }
   
    return f[m - 1][n];
}
```

```c++
//（滚动数组）
	//dp[i][j] 表示从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少。
    //dp[j]为 容量为j的背包所背的最⼤价值
	//dp[j]有两个选择，⼀个是取⾃⼰dp[j]，⼀个是取dp[j - weight[i]] + value[i](容量为j的背包，放⼊物品i了之后的价值即：dp[j])，指定是取最⼤的，毕竟是求最⼤价值，
//////遍历背包容量放在上⼀层，那么每个dp[j]就只会放⼊⼀个物品，即：背包⾥只放⼊了⼀个物品。
int _01beg(int m, int n){//m件物品，n中
    vector<int> dp(n + 1, 0);
    for(int i = 0; i < m; i ++)// 遍历物品
//倒叙遍历是为了保证物品i只被放⼊⼀次！ 以从后往前循环，每次取得状态不会和之前取得状态重合
        for(int j = n; j >= v[i]; j --){// 遍历背包容量
            dp[j] = max(dp[j], dp[j - v[i]]+ w[i]);
        }      
    return dp[n];
}
```

### 7.[**分割等和⼦集**](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x:nums)
            sum += x;
        if(sum & 1) return false;//数组不能分割成两个元素和相等的子集。
        int m = nums.size(), n = sum / 2; 
        // 题⽬中说：每个数组中的元素不会超过 100，数组的⼤⼩不会超过 200
	   // 总和不会⼤于20000，背包最⼤只需要其中⼀半，所以10001⼤⼩就可以了
        vector<int> f(10001, 0);
		//f[i]表示 背包总容量是i，最⼤可以凑成i的⼦集总和为dp[i]。
        for(int i = 0; i < m; i ++)
            for(int j = n; j >= nums[i]; j --) // 每⼀个元素⼀定是不可重复放⼊
                f[j] = max(f[j], f[j - nums[i]] + nums[i]);
        //如果dp[i] == i 说明，集合中的⼦集总和正好可以凑成总和i
        return f[n] == n ? true:false;
    }
};
```

### 8.[**最后⼀块⽯头的重量**](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```c++
class Solution {
public:
//dp[i] 容量j的背包最多背dp[j]中的石头
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(auto x:stones)
            sum += x;
        int m = stones.size(), n = sum / 2;//向下取整 f[n]比sum-f[n]小
        //1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最⼤重量就是30 * 1000
        vector<int> f(15001, 0);
        for(int i = 0; i < m; i++)// 遍历物品
            for(int j = n; j >= stones[i]; j --)// 遍历背包
                f[j] = max(f[j], f[j - stones[i]] +stones[i]);
            	//dp[j - stones[i]]为 容量为j - stones[i]的背包最⼤所背重量
        return sum - f[n] - f[n];
    }
};
```

### 9.[**⽬标和**](https://leetcode-cn.com/problems/target-sum/)

```c++
class Solution {
public:
//加法的和x加减法的和为sum   x-(sum - x) = traget -> x = (traget + sum)/2
//装满容量为x背包，有⼏种⽅法 背包为0 一种方法
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(auto x:nums)
            sum += x;
        //减法和 sum - targe 一定是非负偶数
        if(abs(target) > sum) return 0;
        if(target + sum & 1) return 0;
        int m = nums.size(), n = (target + sum) / 2;
        
        vector<int> f(n + 1, 0);
        f[0] = 1;//背包为0 一种方法  不再是背包里面的价值或者元素和
        for(int i = 0; i < m; i ++)
            for(int j = n; j >= nums[i]; j --)
                {
                    f[j] += f[j - nums[i]];
                }
        return f[n];
    }
};
```

### 10.[**⼀和零**](https://leetcode-cn.com/problems/ones-and-zeroes/)

```c++
class Solution {
public:
//背包有两个维度，⼀个是m ⼀个是n，⽽不同⻓度的字符串就是不同⼤⼩的待装物品
//dp[i][j]：最多有i个0和j个1(背包容量)的strs的最⼤⼦集的⼤⼩为dp[i][j]
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> f(m+1, vector<int>(n+1, 0));
        //strs 统计一共几个1 几个0
        for(string str:strs){//遍历每个字符串
            int zeroNum = 0, oneNum = 0;//每个字符的占位数量 每个物品的重量
            for(char x:str){
                if(x == '0') zeroNum++;
                else oneNum++;
            }
            //倒序 前⼀个strs⾥的字符串推导出来  二维数据
            for(int i = m; i >= zeroNum; i--)// 遍历背包容量且从后向前遍历！
                for(int j = n; j >= oneNum; j--){
//dp[i][j] 可以由前⼀个strs⾥的字符串推导出来，strs⾥的字符串有zeroNum个0，oneNum个1
                    f[i][j] = max(f[i][j], f[i - zeroNum][j -oneNum] + 1);
                }
        }
        return f[m][n];
    }
};
```

## **完全背包理论基础**

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
 	for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
 	//01背包内嵌的循环是从⼤到⼩遍历，为了保证每个物品仅被添加⼀次
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
 	}
}
/*
01背包中⼆维dp数组的两个for遍历的先后循序是可以颠倒了，⼀位dp数组的两个for循环先后循序⼀定是先遍历物品，再遍历背包容量。
在完全背包中，对于⼀维dp数组来说，其实两个for循环嵌套顺序同样⽆所谓！只要保证下标j之前的dp[j]都是经过计算
*/
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    //完全背包的物品是可以添加多次的，所以要从⼩到⼤去遍历
     for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
 	}
}
```

```c++
void bag(int m, int n){
    vector<int> f(n + 1, 0);

    for(int i = 0; i < m; i ++) // 遍历物品
        for(int j = v[i]; j <= n; j ++)// 遍历背包容量
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[n] << endl;
}
```

### 11.[**零钱兑换** **II**](https://leetcode-cn.com/problems/coin-change-2/)

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        //纯完全背包是能否凑成总⾦额，⽽本题是要求凑成总⾦额的个数！
        //dp[j]：凑成总⾦额j的货币组合数为dp[j]
        vector<int> f(amount + 1, 0);
        f[0] = 1;//凑成总⾦额0的货币 组合数 为1  方案 计数
        for(int i = 0; i < coins.size(); i ++){// 遍历物品
            for(int j = coins[i]; j <= amount; j ++)// 遍历背包
//dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。
                f[j] += f[j - coins[i]];
        }
        return f[amount];
    }
};
/*
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
*/
```

### 12.[**组合总和** **Ⅳ**](https://leetcode-cn.com/problems/combination-sum-iv/)

```c++
class Solution {
public:
    //dp[i]: 凑成⽬标正整数为i的排列个数为dp[i]
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> f(target + 1, 0);
        //给定⽬标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式
        f[0] = 1; //排列数
        for(int j = 1; j <= target; j ++){// 遍历背包
            for(int i = 0; i < nums.size(); i ++)// 遍历物品
                if(j - nums[i] >= 0 && f[j] < INT_MAX - f[j - nums[i]]) 
                    f[j] += f[j - nums[i]];
        }
  //C++测试⽤例有超过两个树相加超过int的数据，所以需要在if⾥加上dp[i] < INT_MAX - dp[i - num]。          
        return f[target];
    }
};
```

### 13.[**零钱兑换**](https://leetcode-cn.com/problems/coin-change/)

```c++
class Solution {
public:
//f[i] 凑足i（背包容量）所需的最少硬币个数
    int coinChange(vector<int>& coins, int amount) {
//dp[j]必须初始化为⼀个最⼤的数，否则会在min(dp[j - coins[i]] + 1, dp[j])⽐较的过程中被初始值覆盖。
        vector<int>f(amount+1, INT_MAX);
        f[0] = 0;//凑⾜总⾦额为0所需钱币的个数⼀定是0，
        //求钱币最⼩个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最⼩个数
        for(int i = 0; i < coins.size(); i ++){// 遍历物品
            for(int j = coins[i]; j <= amount; j ++)  // 遍历背包
                f[j] = min(f[j], f[j - coins[i]] +1);
        }         
        if(f[amount] == INT_MAX) return -1;
        return f[amount];
    }
};
```

### 14.[**完全平⽅数**](https://leetcode-cn.com/problems/perfect-squares/)

```c++
class Solution {
public:
    int numSquares(int n) {
        //⾮0下标的dp[i]⼀定要初始为最⼤值，这样dp[j]在递推的时候才不会被初始值覆盖
        vector<int>f(n+1, INT_MAX);
        f[0] = 0;
        //dp[i]：和为i的完全平⽅数 的最少数量为dp[i]
        for(int i = 1; i * i <= n; i ++){ // 遍历物品
            for(int j = 1;  j <= n; j ++) // 遍历背包
                if(j >= i * i )
         //dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]
                    f[j] = min(f[j], f[j - i * i] + 1);
        }   
        return f[n];
    }
};
```

### 15.[**单词拆分**](https://leetcode-cn.com/problems/word-break/)

```c++
class Solution {
public:
    //dp[i] : 字符串⻓度为i的话，dp[i]为true，表示可以拆分为⼀个或多个在字典中出现的单词
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> f(s.size() + 1, false);
        f[0] = true;//为了推导公式。
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        //分割⼦串的特殊性，遍历背包放在外循环,更⽅便
        for(int i = 1; i <= s.size(); i ++)// 遍历背包
            for(int j = 0; j < i; j ++){
                string word = s.substr(j, i - j);
   //确定dp[j] 是true，且 [j, i] 这个区间的⼦串出现在字典⾥，那么dp[i]⼀定是true
                if(wordSet.find(word) != wordSet.end() && f[j])
                    f[i] = true;
            }
        return f[s.size()];
    }
};
```

## **多重背包理论基础**

```c++
//每件物品最多有Mi件可⽤，把Mi件摊开，其实就是⼀个01背包问题
void multi_bag(int m, int n){
    //按nums展开
    for(int i =0; i < nums.size(); i++){
        while(nums[i] > 1){//保留到1，原数组已有一个
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }
    
    vector<int> f(n+1, 0);
    //01背包
    for(int i = 0; i < weight.size(); i ++){
        for(int j = n; j >= weight[i]; j --){
            f[j] = max(f[j], f[j - weight[i]] +value[i]);
        // for(int j = 0; j <= n; j ++)
        //     cout << f[j] << " ";
        }
        // cout<< endl;
    }
    cout << f[n] << endl;
    
}
void multi_bag_rall(int m, int n){
    vector<int> f(n + 1, 0);
    for(int i = 0 ; i <  m; i ++)
        for(int j = n; j >= weight[i]; j --){
            for(int k = 1; k <= nums[i] && j >= k* weight[i]; k ++)
                f[j] = max(f[j], f[j - k * weight[i]] + k * value[i]);
        }
    cout << f[n] << endl;
}
```

## **背包问题**

```markdown
### **背包递推公式**

能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])

- 416.分割等和⼦集
- 1049.最后⼀块⽯头的重量 II

问装满背包有⼏种⽅法：dp[j] += dp[j - nums[i]]

- 494.⽬标和
- \518. 零钱兑换 II
- 377.组合总和Ⅳ
- \70. 爬楼梯进阶版（完全背包）

背包装满最⼤价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

- 474.⼀和零

装满背包所有物品的最⼩个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 

- 322.零钱兑换
- 279.完全平⽅数

### **遍历顺序**

#### **01****背包**

⼆维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第⼆层for循环是从⼩到⼤遍历。

⼀维dp数组01背包只能先遍历物品再遍历背包容量，且第⼆层for循环是从⼤到⼩遍历。

#### **完全背包**

**如果求组合数就是外层*for*循环遍历物品，内层*for*遍历背包**。

**如果求排列数就是外层*for遍历背包，内层*for循环遍历物品**。

组合数：    518.零钱兑换II

排列数：    377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包）

**如果求最⼩数，那么两层for循环的先后顺序**就⽆所谓 

最⼩数：    322. 零钱兑换、动态规划：279.完全平⽅数
```

## 股票问题

### **198.**[打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```c++
class Solution {
public:
    //dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的⾦额为dp[i]。
    int rob(vector<int>& nums) {
        vector<int> f(nums.size());
        if(!nums.size()) return 0;
        if(nums.size() == 1) return nums[0];
        //递推公式的基础就是dp[0] 和 dp[1]
        f[0] = nums[0];
        f[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i ++){
            //偷或者不偷第i个房间
            f[i] = max(f[i - 1], f[i - 2] + nums[i]);
        }
        for(auto x : f)
            cout <<  x <<" ";
        return f[nums.size() - 1];
    }
};
```

### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```c++
/*
对于⼀个数组，成环的话主要有如下三种情况：
情况⼀：考虑不包含⾸尾元素
情况⼆：考虑包含⾸元素，不包含尾元素
情况三：考虑包含尾元素，不包含⾸元素
*/
class Solution {
public:
    int rob(vector<int>& nums) {
        //成环的条件考虑  
        //情况⼆ 和 情况三 都包含了情况⼀了，所以只考虑情况⼆和情况三就可
        if(!nums.size()) return 0;
        if(nums.size() == 1) return nums[0];
        return max(rob_1(nums, 0, nums.size() - 2), rob_1(nums, 1, nums.size() - 1));
    }
    int rob_1(vector<int> nums, int start, int end){
        if(start == end) return nums[start];
        vector<int> f(nums.size());
        f[start] = nums[start];
        f[start + 1] = max(nums[start], nums[start + 1]);
        for(int i = start + 2; i <= end; i ++){
            f[i] = max(f[i - 1], f[i - 2] + nums[i]);
        }

        return f[end];
    }
};
```

### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```c++
/*
遍历⽅式
前中后序（深度优先搜索）还是层序遍历（⼴度优先搜索）。
本题⼀定是要后序遍历，因为   通过递归函数的返回值来做下⼀步计算。
记忆化递推
可以使⽤⼀个map把计算过的结果保存⼀下，这样如果计算过孙⼦了，那么计算孩⼦的时候可以复
⽤孙⼦节点的结果
*/
class Solution {
public:
    unordered_map<TreeNode*, int> umap;// 记录计算过的结果
    int rob(TreeNode* root) {
        if(!root) return 0;
        if(!root->left && !root->right) return root->val;
        if(umap[root]) return umap[root];// 如果umap⾥已经有记录则直接返回
        // 偷⽗节点
        int res1 = root->val;
        // 跳过root->left
        if(root->left) res1 += rob(root->left->left) + rob(root->left->right);
        // 跳过root->right
        if(root->right) res1 += rob(root->right->left) + rob(root->right->right);
        // 不偷⽗节点
        int res2 = rob(root->left) + rob(root->right);// 考虑root的左右孩⼦
        umap[root] = max(res1, res2);// umap记录⼀下结果
        return max(res1, res2);
    }
};
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
//树形dp  在树上进⾏状态转移
class Solution {
public:
//dp数组以及下标的含义：下标为0记录不偷该节点所得到的的最⼤⾦钱，下标为1记录偷该节点所得到的的最⼤⾦钱。
    int rob(TreeNode* root) {
        vector<int>  res = robtree(root);
        return max(res[0], res[1]);
    }
    // ⻓度为2的数组，0：不偷，1：偷
    vector<int> robtree(TreeNode* cur){
        if(!cur) return vector<int>{0, 0};//终⽌条件
        //后序遍历 
        vector<int> left = robtree(cur->left);
        vector<int> right= robtree(cur->right);
        //中
        //偷cur   左右孩⼦就不能偷
        int res1 = cur->val + left[0] + right[0];
        //不偷cur 左右孩⼦就可以偷
        int res2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {res2, res1};
    }
};
```

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```c++
//贪心  //dp[i][1] 表示第i天不持有股票所得最多现⾦取最左最⼩值，取最右最⼤值，那么得到的差值就是最⼤利润。
//dp[i][0] 表示第i天持有股票所得最多现⾦
 	//第i-1天就持有股票，那么就保持现状，所得现⾦就是昨天持有股票的所得现⾦ 即：dp[i - 1][0]
	//第i天买⼊股票，所得现⾦就是买⼊今天的股票后所得现⾦即：-prices[i]
//dp[i][1] 表示第i天不持有股票所得最多现⾦
 	//第i-1天就不持有股票，那么就保持现状，所得现⾦就是昨天不持有股票的所得现⾦ 即：dp[i - 1][1]
	//第i天卖出股票，所得现⾦就是按照今天股票佳价格卖出后所得现⾦即：prices[i] + dp[i - 1][0]
    
//基础都是要从dp[0][0]和dp[0][1]推导出来。 
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> f(prices.size(), vector<int>(2));
        if(!prices.size()) return 0;
        f[0][0] -= prices[0];
        f[0][1] = 0;
        for(int i = 1; i < prices.size(); i++){
            f[i][0] = max(f[i - 1][0], -prices[i]);
            f[i][1] = max(f[i - 1][1], prices[i] + f[i - 1][0]);
        }
        return f[prices.size() - 1][1];
    }
};
```

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```c++
//区别本题股票可以买卖多次
/*
dp[i][0] 表示第i天持有股票所得现⾦。
	第i-1天就持有股票			dp[i - 1][0]
	第i天买⼊股票  可以买卖多次  dp[i - 1][1] - prices[i]。
dp[i][1] 表示第i天不持有股票所得最多现⾦
*/

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n) return 0;
        vector<vector<int>> f(n, vector<int>(2));
        f[0][0] -= prices[0];
        f[0][1] = 0;
        for(int i = 1; i < n; i++){
            f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i]);
        }
        return f[n - 1][1];
    }
};
```

### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```c++
/*
⼀天⼀共就有五个状态，
0. 没有操作
1. 第⼀次买⼊ dp[0][1] = -prices[0];
	操作⼀：第i天买⼊股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
	操作⼆：第i天没有操作，⽽是沿⽤前⼀天买⼊的状态，即：dp[i][1] = dp[i - 1][1]
2. 第⼀次卖出 dp[0][2] = 0 卖出的操作是收获利润 如果⽐0还⼩了就没有必要
	操作⼀：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
	操作⼆：第i天没有操作，沿⽤前⼀天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]
3. 第⼆次买⼊ 
4. 第⼆次卖出 dp[0][4] = 0
dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最⼤现⾦
*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n) return 0;
        vector<vector<int>>f(n + 1, vector<int>(5));
        f[0][1] = - prices[0];
        f[0][3] = - prices[0];
        for(int i = 1; i < n; i++){
            //f[i][0] = f[i - 1][0];
            f[i][1] = max(f[i - 1][1], f[i - 1][0] - prices[i]);
            f[i][2] = max(f[i - 1][2], f[i - 1][1] + prices[i]);
            f[i][3] = max(f[i - 1][3], f[i - 1][2] - prices[i]);
            f[i][4] = max(f[i - 1][4], f[i - 1][3] + prices[i]);
        }
        return f[n - 1][4];
    }
};
```

### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```c++
/*
使⽤⼆维数组 dp[i][j] ：第i天的状态为j，所剩下的最⼤现⾦是dp[i][j]
	j 	状态表示为：
    0 	表示不操作  除了0以外，偶数就是卖出，奇数就是买⼊。
    1 	第⼀次买⼊
    2 	第⼀次卖出
    3 	第⼆次买⼊
    4 	第⼆次卖出
    5 	  三
    6 	  三
   2k-1	  k
    2k 	  k
.....   
*/
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(!n) return 0;
        vector<vector<int>>f(n + 1, vector<int>(2 * k + 1));
        //dp[0][j]当j为奇数的时候都初始化为 -prices[0]  偶数的最大利润初始化为0
        for(int i = 1; i < 2 * k; i += 2){
            f[0][i] = - prices[0];
        }
        for(int i = 1; i < n; i++){
            for(int j = 0; j < 2 * k - 1; j += 2){//从0开始
                //奇数买入
                f[i][j + 1] = max(f[i - 1][j + 1], f[i - 1][j] - prices[i]);
                //偶数卖出
                f[i][j + 2] = max(f[i - 1][j + 2], f[i - 1][j + 1] + prices[i]);
            }
        }
        return f[n - 1][2 * k];
    }
};
```

### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```c++
/*
dp[i][j]，第i天状态为j，所剩的最多现⾦为dp[i][j]。

状态⼀：买⼊股票状态  前⼀天就是持有股票状态（状态⼀），今天买⼊了有两种情况 前⼀天是冷冻期（状态四），前⼀天是保持卖出股票状态（状态⼆）
卖出股票状态，这⾥就有两种卖出股票状态
    状态⼆：达到保持卖出股票状态（状态⼆） 前⼀天就是状态⼆ 前⼀天是冷冻期（状态四） 
    状态三：达到今天就卖出股票状态（状态三）  昨天⼀定是买⼊股票状态（状态⼀），今天卖出  
状态四：今天为冷冻期状态，只有⼀天 只有⼀个操作:昨天卖出了股票（状态三） 

j的状态为：
0：状态⼀ dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]
1：状态⼆ dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
2：状态三 dp[i][2] = dp[i - 1][0] + prices[i];  //昨天⼀定是买⼊股票状态 是状态
3：状态四 dp[i][3] = dp[i - 1][2];   //昨天卖出了股票
初始化
如果是持有股票状态（状态⼀）, dp[0][0] = -prices[0]，买⼊股票所省现⾦为负数。
保持卖出股票状态（状态⼆），第0天没有卖出dp[0][1]初始化为0就⾏，
今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。
同理dp[0][3]也初始为0。
*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n) return 0;
        vector<vector<int>>f(n, vector<int>(5));
        f[0][0] = -prices[0];
        for(int i = 1; i < n; i ++){
            f[i][0] = max(f[i - 1][0], max(f[i - 1][3] - prices[i], f[i - 1][1] - prices[i]));
            f[i][1] = max(f[i - 1][1], f[i - 1][3]);
            f[i][2] = f[i - 1][0] + prices[i];
            f[i][3] = f[i - 1][2];
        }
        for(auto x : f){
            for(auto &y : x)
                cout << y << " ";
            cout << endl;
        }
            
        return max(f[n - 1][1], max(f[n - 1][2], f[n - 1][3]));
    }
};
```

### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```c++
/*
只需要在计算卖出操作的时候减去⼿续费就可
dp[i][0] 表示第i天持有股票所省最多现⾦。
dp[i][1] 表示第i天不持有股票所得最多现⾦
*/
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(!n) return 0;
        vector<vector<int>>f(n, vector<int>(2));
        f[0][0] = -prices[0];// 持股票
        //f[0][1] = 0;
        for(int i = 1; i < n; i ++){
            f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i] - fee);
        }  
        return max(f[n - 1][0], f[n - 1][1]);
    }
};
```

## 序列问题

### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```c++
/*
dp[i]表示i之前包括i的最⻓上升⼦序列。（j < i）
 位置i的最⻓升序⼦序列等于j从0到i-1各个位置的最⻓升序⼦序列 + 1 的最⼤值。
*/
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n <= 1) return n;
        vector<int> f(n, 1);
        int res = 0;
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j ++){
                if(nums[i] > nums[j]) f[i] = max(f[i], f[j] + 1);//不是要dp[i] 与 dp[j] + 1进⾏⽐较，⽽是我们要取dp[j] + 1的最⼤值
            }
            res = res < f[i] ? f[i]:res;// 取⻓的⼦序列
        }
        return res;
    }
};
```

### [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

```c++
//贪心
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        if(n <= 1) return n;
        int cout = 1, res = 1;
        for(int i = 0; i < n - 1; i++){
            if(nums[i + 1] > nums[i])
                cout ++;
            else
                cout = 1;
            res = res > cout ? res : cout;
        }
        return res;
    }
};


/*
要求连续递增⼦序列，所以就必要⽐较nums[i + 1]与nums[i]，⽽不⽤去⽐较nums[j]与nums[i] （j是在0到i之间遍历）。
dp[i]：以下标i为结尾的数组的连续递增的⼦序列⻓度为dp[i]。
如果 nums[i + 1] > nums[i]，那么以 i+1 为结尾的数组的连续递增的⼦序列⻓度 ⼀定等于 以i为结尾的
数组的连续递增的⼦序列⻓度 + 1 。
*/
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
       int n = nums.size();
       if(n <= 1) return n;
       vector<int> f(n, 1);
       int res = 0;
       for(int i = 0; i < n - 1; i++){
           if(nums[i + 1] > nums[i])    // 连续记录
               f[i + 1] = f[i] + 1;		// 递推公式
           res = f[i + 1] > res ? f[i +1] : res; 
       }
       return res;
    }
};
```

### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```c++
/*
dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最⻓重复⼦数组⻓度为dp[i][j]
dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来，在遍历dp[i][j]的时候i 和 j都要从1开始
当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;
*/
class Solution {
public:
//dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最⻓重复⼦数组⻓度为dp[i][j]。
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1, 0));
        int res = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(nums1[i - 1] == nums2[ j - 1])
                    f[i][j] = f[i - 1][j - 1] + 1; 
                res = f[i][j] > res ? f[i][j] :res;
            }
        }
        return res;
    }
};
时间复杂度O(n * m) n 为A⻓度，m为B⻓度
空间复杂度O(n * m)
//滚动数组
//压缩为⼀维数组，也就是dp[j]都是由dp[j - 1]推出 相当于可以把上⼀层dp[i - 1][j]拷⻉到下⼀层dp[i][j]来继续⽤
// 遍历B数组的时候，就要从后向前遍历，这样避免重复覆盖。
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector<int> f(m + 1, 0);
        int res = 0;
        for(int i = 1; i <= n; i ++){
            for(int j = m; j > 0; j--){//从后向前遍历,避免重复覆盖
                if(nums1[i - 1] == nums2[j - 1])
                    f[j] = f[j - 1] + 1;
                else
                    f[j] = 0;// 这⾥不相等的时候要有赋0的操作
                res = res > f[j] ? res:f[j];
            }
        }
        return res;
    }
};
时间复杂度O(n * m) n 为A⻓度，m为B⻓度
空间复杂度O(m)
```

### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```c++
/*
这⾥不要求是连续的了，但要有相对顺序
dp[i][j]：⻓度为[0, i - 1]的字符串text1与⻓度为[0, j - 1]的字符串text2的最⻓公共⼦序列为dp[i][j]

text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同
 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了⼀个公共元素
 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最⻓公共⼦序列 和text1[0, i - 1]与text2[0, j - 2]的最⻓公共⼦序列，取最⼤的
*/ 
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2){
        int n = text1.size(), m = text2.size();
        vector<vector<int>> f(n + 1, vector<int>(m + 1));
        int res = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j ++){
                if(text1[i - 1] == text2[j - 1])
                    f[i][j] = f[i - 1][j - 1] + 1;
                else
                    f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                
                res = f[i][j] > res ? f[i][j] : res;
            }
        }
        return res;
    }
};
```

#### [1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

```c++
//在字符串A中 找到⼀个与字符串B相同的⼦序列，且这个⼦序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1));
        int res = 0;
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                if(nums1[i - 1] == nums2[ j - 1])
                    f[i][j] = f[i - 1][j - 1] + 1;
                else 
                    f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                res = res < f[i][j] ? f[i][j] : res;
            }
        }
        return res;
    }
};
```

### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```c++
/*
dp[i]：包括下标i之前的最⼤连续⼦序列和为dp[i]。
dp[i]只有两个⽅向可以推出来：
	dp[i - 1] + nums[i]，即：nums[i]加⼊当前连续⼦序列和
	nums[i]，即：从头开始计算当前连续⼦序列和
dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础 dp[0] = nums[0]。
*/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(!n) return 0;
        vector<int>f(n);
        f[0] = nums[0];
        int res = f[0];
        for(int i = 1; i < n; i ++){
            f[i] = max(f[i - 1] + nums[i], nums[i]); // 状态转移公式
            res = f[i] > res ? f[i] : res;// result 保存dp[i]的最⼤值
        }
        return res;
    }
};
```

### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

```c++
/*
dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同⼦序列的⻓度为dp[i][j]。
两种操作:
if (s[i - 1] == t[j - 1])
	t中找到了⼀个字符在s中也出现了 dp[i][j] = dp[i - 1][j - 1] + 1
if (s[i - 1] != t[j - 1])
	相当于t要删除元素，继续匹配 dp[i][j] = dp[i][j - 1]
*/
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.size(), m = t.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1));
        bool res = false;
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                if(s[i - 1] == t[j - 1]) 
                    f[i][j] = f[i - 1][j - 1] + 1;
                else 
                    f[i][j] = f[i][j - 1];
            }
        }
        return f[n][m] == n;                   
    }
};
```

### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

```c++
/*
dp[i][j]：以i-1为结尾的s⼦序列中出现以j-1为结尾的t的个数为dp[i][j]
    s[i - 1] 与 t[j - 1]相等
    	⼀部分是⽤s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。 
		⼀部分是不⽤s[i - 1]来匹配，个数为dp[i - 1][j]。  如s：bagg 和 t：bag
    s[i - 1] 与 t[j - 1] 不相等 
    	dp[i][j]只有⼀部分组成，不⽤s[i - 1]来匹配，即：dp[i - 1][j]
    	
dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。
	把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。
dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。
 	dp[0][j]⼀定都是0，s如论如何也变成不了t。
dp[0][0]
dp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。
*/
class Solution {
public:
 //dp[i][j]：以i-1为结尾的s⼦序列中出现以j-1为结尾的t的个数为dp[i][j]。
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        vector<vector<uint32_t>>f(n + 1, vector<uint32_t>(m + 1));
        for(int i = 0; i <= n; i ++) f[i][0] = 1;
        for(int j = 1; j <= m; j ++) f[0][j] = 0;
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j++){
                if(s[i - 1] == t[j - 1]) 
                    f[i][j] = f[i - 1][j - 1] + f[i - 1][j];
                else
                    f[i][j] = f[i - 1][j];
            }
        }
        return f[n][m];
    }
};
```

### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

```c++
/*
dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素
的最少次数。
当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1]; 当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：
	情况⼀：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
	情况⼆：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
	情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2
dp[i][0]：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同 dp[i][0] = i。
*/
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1));
        for(int i = 0; i <= n; i ++) f[i][0] = i;
        for(int j = 0; j <= m; j ++) f[0][j] = j;

        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j ++){
                if(word1[i - 1] == word2[j - 1])
                    f[i][j] = f[i - 1][j - 1];
                else
                    f[i][j] = min({f[i - 1][j - 1] + 2, f[i - 1][j] + 1, f[i][j - 1] + 1});
            }
        }
        return f[n][m];
    }   
};
 
//数学关系 公共子序列问题
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1));
        int res = 0;
        for(int i = 1; i <= n ; i ++){
            for(int j = 1; j <= m; j ++){
                if(word1[i - 1] == word2[j - 1])
                    f[i][j] = f[i - 1][j - 1] + 1;
                else
                    f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                res = f[i][j] > res ? f[i][j] : res;
            }
        }
        return n + m - res - res;
    }
};
```

### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```c++
/*
dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为
dp[i][j]。
if (word1[i - 1] == word2[j - 1])
	 不操作  dp[i][j] = dp[i - 1][j - 1]
if (word1[i - 1] != word2[j - 1])
	 增 word1删除⼀个元素,就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编
辑距离 再加上⼀个操作。 dp[i][j] = dp[i - 1][j] + 1
 	 删 word2删除⼀个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编
辑距离 再加上⼀个操作  dp[i][j - 1] + 1
 	 换 word1 替换 word1[i - 1] ，使其与 word2[j - 1] 相同，此时不⽤增加元素，那
么以下标 i-2 为结尾的 word1 与 j-2 为结尾的 word2 的最近编辑距离 加上⼀个替换元素的操作。dp[i][j] = dp[i - 1][j - 1] + 1	

dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。
dp[i][0] = i
dp[0][j] = j
*/
class Solution {
public:

    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1));
        for(int i = 0; i <= n; i ++) f[i][0] = i;
        for(int j = 0; j <= m; j ++) f[0][j] = j;

        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= m; j++){
                if(word1[i - 1] == word2[j - 1])
                    f[i][j] = f[i - 1][j - 1];
                else
                //word2添加⼀个元素，相当于word1删除⼀个元素
                    f[i][j] = min({f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + 1});
            }
        }
        return f[n][m];
    }
};

```

### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```c++
/*
布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的⼦串是否是回⽂⼦串，如果是dp[i][j]为
true，否则为false。

整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。
当s[i]与s[j]不相等,dp[i][j]⼀定是false。 
当s[i]与s[j]相等时，这就复杂⼀些了，有如下三种情况
	情况⼀：下标i 与 j相同，同⼀个字符例如a，当然是回⽂⼦串
	情况⼆：下标i 与 j相差为1，例如aa，也是⽂⼦串
	情况三：下标：i 与 j相差⼤于1的时候，这个区间是不是回⽂就看dp[i + 1][j - 1]是否为true
*/
/*
当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]⼀定是false。 当s[i]与s[j]相等时，这就复杂⼀些了，有如下三种情况
情况⼀：下标i 与 j相同，同⼀个字符例如a，当然是回⽂⼦串
情况⼆：下标i 与 j相差为1，例如aa，也是⽂⼦串
情况三：下标：i 与 j相差⼤于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是
不是回⽂⼦串就看aba是不是回⽂就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是
回⽂就看dp[i + 1][j - 1]是否为true。
*/
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        vector<vector<bool>>f(n, vector<bool>(n, false));
        int res = 0;
        for(int i = n - 1; i >= 0; i --){
            for(int j = i; j < n; j ++){
                if(s[i] == s[j] && (j - i <= 1 || f[i + 1][j - 1]))
                    res ++, f[i][j] = true;
                // if(s[i] == s[j]){//不等直接false
                //     if(j - i <= 1) { //下表相同或差1 
                //         res ++;
                //         f[i][j] = true;
                //     }
                //     else if(f[i + 1][j - 1]){//情况三
                //     res ++;
                //     f[i][j] = true;
                //     }
                // }
            }
        }
        return res;
    }
};

//双指针
class Solution {
public:
    int countSubstrings(string s) {
        int res = 0;
        int n = s.size();
        for(int i = 0; i < n; i++){
            res += extend(s, i, i, n);
            res += extend(s, i, i + 1, n);
        }
        return res;
    }
    int extend(const string& s, int left, int right, int len){
        int res = 0;
        while(left >= 0 && right < len && s[left] == s[right]){
            left --;
            right ++;
            res ++;
        }
        return res;
    }
};
```

### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```c++
/*
dp[i][j]：字符串s在[i, j]范围内最⻓的回⽂⼦序列的⻓度为dp[i][j]

如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;
如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加⼊ 并不能增加[i,j]区间回⽂⼦串的⻓度，那么分别加⼊s[i]
s[j]看看哪⼀个可以组成最⻓的回⽂⼦序列。
	加⼊s[j]的回⽂⼦序列⻓度为dp[i + 1][j]。
	加⼊s[i]的回⽂⼦序列⻓度为dp[i][j - 1]。
*/
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>>f(n, vector<int>(n));
        //当i与j相同，那么dp[i][j]⼀定是等于1的
        for(int i = 0; i < n; i++) f[i][i] = 1;
        //遍历顺序和递推公式息息相关
        for(int i = n - 1; i >= 0; i --){
            for(int j = i + 1; j < n; j ++){
                if(s[i] == s[j])
                    f[i][j] = f[i + 1][j - 1] + 2;
                else
                    f[i][j] = max(f[i + 1][j], f[i][j - 1]);
            }
        } 
        return f[0][n - 1];
    }
};
```

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        int begin = 0;
        int maxlen = 1;
        vector<vector<bool>>f(n, vector<bool>(n, false));
        for(int  i = n - 1; i >= 0; i --){
            for(int j = i; j < n; j++){
                if(s[i] == s[j] && (j - i <= 1 || f[i + 1][j - 1]))
                    f[i][j] = true;
                if(f[i][j] && j - i + 1 > maxlen){
                    maxlen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxlen);
    }
};
```



## 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。**

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

[每日测温！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247489773&idx=1&sn=2022454b723475adc0507a2d43b68bdc&scene=21#wechat_redirect)

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int>st;
        vector<int>res(temperatures.size(), 0);
        st.push(0);
        for(int i = 1; i<temperatures.size(); i++){
            // if(temperatures[i] <temperatures[st.top()])
            //     st.push(i);
            // else if(temperatures[i] == temperatures[st.top()])
            //     st.push(i);
            // else {
            //     while(!st.empty()&&temperatures[i] > temperatures[st.top()]){
            //         res[st.top()] = i - st.top();
            //         st.pop();
            //     }
            //     st.push(i);
            while(!st.empty()&&temperatures[i]>temperatures[st.top()]){
                res[st.top()] = i - st.top();
                st.pop();
                }
            st.push(i);
         //   }
        }
        return res;
    }
}; 
```

### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```c++
/*
栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素
如下三种情况，一定要分析清楚。
情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
此时满足递增栈（栈头到栈底的顺序），所以直接入栈。
情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！
情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。
判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。
记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2中右面第一个大的元素是nums2[i]即当前遍历元素
*/
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下表元素，value：下表
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下表
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};

class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下表元素，value：下表
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            while (!st.empty() && nums2[i] > nums2[st.top()]) {
                if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                    int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下表
                    result[index] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
        return result;
    }
};
```

### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```c++
/*
把两个数组拼接在一起  模拟走了两边nums
*/
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 拼接一个新的nums
        vector<int> nums1(nums.begin(), nums.end());
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        // 用新的nums大小来初始化result
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result; 
        // 开始单调栈
        stack<int> st;
        for (int i = 0; i < nums.size(); i++) {
            while (!st.empty() && nums[i] > nums[st.top()]) {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
        // 最后再把结果集即result数组resize到原数组大小
        result.resize(nums.size() / 2);
        return result;
    }
};

class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) { 
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return result;
    }
};
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/submissions/)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0;
        for (int i = 0; i < height.size(); i++) {
            // 第一个柱子和最后一个柱子不接雨水
            if (i == 0 || i == height.size() - 1) continue;

            int rHeight = height[i]; // 记录右边柱子的最高高度
            int lHeight = height[i]; // 记录左边柱子的最高高度
            for (int r = i + 1; r < height.size(); r++) {
                if (height[r] > rHeight) rHeight = height[r];
            }
            for (int l = i - 1; l >= 0; l--) {
                if (height[l] > lHeight) lHeight = height[l];
            }
            int h = min(lHeight, rHeight) - height[i];
            if (h > 0) sum += h;
        }
        return sum;
    }
};

class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        // 记录每个柱子左边柱子最大高度
        maxLeft[0] = height[0];
        for (int i = 1; i < size; i++) {
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        }
        // 记录每个柱子右边柱子最大高度
        maxRight[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            maxRight[i] = max(height[i], maxRight[i + 1]);
        }
        // 求和
        int sum = 0;
        for (int i = 0; i < size; i++) {
            int count = min(maxLeft[i], maxRight[i]) - height[i];
            if (count > 0) sum += count;
        }
        return sum;
    }
};

class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        st.push(0);
        int sum = 0;
        for (int i = 1; i < height.size(); i++) {
            while (!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if (!st.empty()) {
                    int h = min(height[st.top()], height[i]) - height[mid];
                    int w = i - st.top() - 1;
                    sum += h * w;
                }
            }
            st.push(i);
        }
        return sum;
    }
};
```

