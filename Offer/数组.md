## **数组**

```c++
二分模板一共有两个，分别适用于不同情况。
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
版本2
当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}


// 当left==right，区间[left, right]依然有效，所以用 <=  
//是不是依旧有效
```



###  [704. 二分查找](https://leetcode.cn/problems/binary-search/)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size();
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] > target) r = mid;
            else if(nums[mid] <target) l = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        vector<int>f(2, -1);
        if(!nums.size()) return f;
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if(nums[l] != target) return f;
        else {
            f[0] = l;
            int l = 0, r = nums.size() - 1;
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(nums[mid] <= target) l = mid;
                else r = mid - 1;
            }
            f[1] = l;
        }
        return f;
    }
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        vector<int>f(2, -1);
        if(!nums.size()) return f;
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if(nums[l] != target) return f;
        else {
            f[0] = l;
            int l = 0, r = nums.size() - 1;
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(nums[mid] <= target) l = mid;
                else r = mid - 1;
            }
            f[1] = l;
        }
        return f;
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```c++
class Solution {
public:
    int mySqrt(int x) {
        long long  l = 0, r = x;
        while(l < r){
            long long  mid = (l + r + 1) >> 1;//小数部分将被舍去
            if((long long)mid * mid <= x) l = mid;
            else r = mid - 1;
        }
        cout << l << " "<< r;
        return l;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 0, r = num;
        while(l <= r){
            int mid = (r + l) >> 1;
            if((long)mid * mid > num) r = mid - 1;
            else if((long)mid * mid < num) l = mid  + 1;
            else return true;
        }
        return false;
    }
};
```

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv43W2OFzic9tNsB9dGwCaYbQ1Td0CliauEJ9O31cb7bLxS9AsXN6Of0icic2rBuNBrwP9ibPsqHQEI2BTA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //快慢指针的操作
        int slow = 0;
        for(int fast = 0; fast < nums.size(); fast ++){
            if(nums[fast] != val){
                nums[slow++]  = nums[fast]; 
            }
        }
        return slow;
    }
};

```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int l = 1, r = 1;
        while(r < nums.size()){
            if(nums[r] != nums[r - 1]){
                nums[l] = nums[r];//覆盖  不等时候
                l ++;
            }
            r++;//一直走寻找下一个不等的将其覆盖
        }
        return l;
    }
};

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int slow = 1;
        for(int fast = 1; fast < nums.size(); fast++){//从第二个元素开始
            if(nums[fast] != nums[fast - 1])
                nums[slow++] =nums[fast];
        }
        return slow;
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int l = 0, r = 0;
        while(r < nums.size()){
            if(nums[r]){
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
        cout << r - l<<endl;
    }
};

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int l = 0, r = 0;
        while(r < nums.size()){
            if(nums[r]){
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
        cout << r - l<<endl;
    }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```c++
class Solution {
public:
    string rebuild(string s){
        string str;
        for(auto x:s){
            if(x != '#')
                str.push_back(x);
            else if(!str.empty())
                str.pop_back();
        }
        return str;
    }
    bool backspaceCompare(string s, string t) {
        return rebuild(s) == rebuild(t);
    }
};
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv49PTAcQFBFFQtyH6RIEERSMIU4yk8AYZ3XI8cF1wJszznjJ1etuFxu4ibvvndawdu3nxfwUpibp9kA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;
        vector<int> res(k + 1, 0);
        int i = 0, j = k;
        while(i <= j){// 注意这里要i <= j，因为最后要处理两个元素
            if(nums[i] * nums[i] < nums[j] * nums[j]){
                res[k--] = nums[j] * nums[j];
                j--;
            }
            else{
                res[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return res;
    }
};
```

### [209. 长度最小的子数组-划窗](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6Dh6cLPrfmXOctLPWibfcWd4gzEh6DCeqpTNtAzEBtzpxf4JZfBOMnt7xEWYj5QJp22uzfUMYkxaQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = 0;
        int cout = INT_MAX;
        for(int i = 0; i < nums.size(); i++){
            int sum = 0;
            for(int j = i; j < nums.size(); j++){
                sum += nums[j];
                if(sum >= target){
                    len = j - i + 1;
                    cout = cout < len ? cout:len;
                    break;
                }
            }
        }
        return cout == INT_MAX?0:cout;
    }
};

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int l = 0,  r =0;//滑动窗口起始和结束位置
        int sum = 0;
        int len = 0;
        while(r < nums.size()){
            sum += nums[r];
             //使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while(sum >= target){
                len = r - l + 1;
                res = res<len?res:len;
                sum -= nums[l];
                l++;//滑动窗口的精髓，不断变更i（子序列的起始位置）
            }
            r++;
        }
         // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return res == INT_MAX?0:res;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> map;
        int len = 0, res = 0;
        int l = 0, r = 0;
        while(r < fruits.size()){
            map[fruits[r]]++;
            len++;
            while(map.size() > 2){
                map[fruits[l]] --;
                if(!map[fruits[l]]) map.erase(fruits[l]);
                len --;
                l++;
            }
            res = res>len?res:len;
            r++;
        }
        return res;
    }
};
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();
        unordered_map<char,int>map(n);
        // 将字符串t中每个字母出现的次数统计出来，这里--可以理解为有这么多的坑要填
        for(auto x:t)   
            map[x]--;
        string res = "";
        int l = 0, r = 0, cnt = 0;
        while(r < n){
            // 利用字符s[i]去填count数组的坑
            map[s[r]] ++;
// 如果cnt等于t.length，那么说明窗口内已经包含t了，这时就要考虑移动左指针了，只有当左指针指向的字符是冗余的情况下，即count[cs[j]]>0，才能保证去掉该字符后，窗口中仍然包含t
            // 注意cnt达到字符串t的长度后，它的值就不会再变化了，因为窗口内包含t之后，就会一直包含
            if(map[s[r]] <= 0) cnt ++; //有效坑位
// 如果cnt等于ct.length，那么说明窗口内已经包含t了，这时就要考虑移动左指针了，只有当左指针指向的字符是冗余的情况下，即count[cs[j]]>0，才能保证去掉该字符后，窗口中仍然包含t
// 注意cnt达到字符串t的长度后，它的值就不会再变化了，因为窗口内包含t之后，就会一直包含
            while(cnt == m && map[s[l]] > 0){
                map[s[l]]--;
                l++;
            }
            // 当窗口内包含t后，计算此时窗口内字符串的长度，更新res
            if(cnt == m){
                if(res == "" || res.size() > r - l + 1)
                    res = s.substr(l, r - l  +1);
            }
            r++;
        }
        return res;
    }
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>res(n, vector<int>(n));
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y =0, d = 1;
        for(int i = 1; i <= n * n; i++){
            res[x][y] = i;
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b < 0 || b>=n || res[a][b]){ //已经访问过此位置
                d = (d + 1) % 4; // 顺时针旋转至下一个方向
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n = matrix.size(), m = matrix[0].size();
        if(!n) return res;

        vector<vector<bool>>st(n, vector<bool>(m, false));
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;
        for(int i = 0; i < n * m; i ++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b < 0 || b >= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
```

### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int n = matrix.size();//这里问题很大  哈哈哈哈哈
        if(!n) return res;
        int m = matrix[0].size();
        vector<vector<bool>> st(n, vector<bool>(m, false));

        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;

        for(int i = 0; i < n * m; i++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
             
            int a = x + dx[d], b = y + dy[d];
            if(a < 0 || a >= n || b <0 || b >= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;

    }
};
```

## **链表**

#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        auto dummynode = new ListNode(0);
        dummynode->next = head;
        auto cur = dummynode;
        while(cur->next){
            if(cur->next->val == val){
                auto tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }
            else 
                cur = cur->next;
        }
        head = dummynode->next;
        delete dummynode;
        return head;
    }
};
//定义dummyHead的时候，不定义指针，而是定义实体
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummyHead; // 设置一个虚拟头结点
        dummyHead.next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = &dummyHead;
        while (cur->next ) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        return dummyHead.next;
    }
};
```

### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    void addAtIndex(int index, int val) {
        if (index > _size) {
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;//可以指定的  是要前一个pre 还是cur
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv7ftmCo9j6fqIwpACbibyzDaeAjalAsyVzzxgSYicicuV3TH3vzia4rANEUghDYQPdiajHNJaWvsDTBSLQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        auto cur = head;
        while(cur){
            auto  node = cur->next;
            cur->next = pre;
            pre = cur;
            cur = node;
        }
        return pre;
    }
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr, head);
    }
    ListNode* reverse(ListNode* pre, ListNode* cur){
        if(!cur) return pre;
        auto tmp = cur->next;
        cur->next = pre;
        
        return reverse(cur, tmp);
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummynode = new ListNode(0);
        dummynode->next = head;
        auto fast = dummynode;
        auto slow = dummynode;
        while(n-- && fast){
            fast = fast->next;
        }
        // fast再提前走一步，让slow指向删除节点的上一个节点(删除操作)
        fast = fast->next;
        while(fast){
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummynode->next;
    }
};
```

### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode *> visited;
        ListNode *temp = headA;
        while (temp != nullptr) {
            visited.insert(temp);
            temp = temp->next;
        }
        temp = headB;
        while (temp != nullptr) {
            if (visited.count(temp)) {
                return temp;
            }
            temp = temp->next;
        }
        return nullptr;
    }
};
 

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {//为什么有如此牛逼的想法
        if(!headA || !headB)
            return nullptr;
        auto curA = headA, curB = headB;
        while(curA != curB){
            curA = curA == nullptr?headA:curA->next;
            curB = curB == nullptr?headB:curB->next;
        }
        return curB;
        
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
//假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next
        auto fast = head->next;
        auto slow = head;
        while(fast != slow){//循环条件先于循环体
            if(!fast || !fast->next) return false;
            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
    }
};

class Solution {
public:
    bool hasCycle(ListNode *head) {
       auto fast = head, slow = head;
       while(fast && fast->next){
           slow = slow->next;
           fast = fast->next->next;
           if(fast == slow)
            return true;
       } 
       return false;
    }
};
```



### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
       if(!head || !head->next) return nullptr;
       auto fast = head;
       auto slow = head;
       while(fast && fast->next){
           fast = fast->next->next;
           slow = slow->next;
           if(slow == fast){
               slow = head;
               while(fast != slow){
                   fast = fast->next;
                   slow = slow->next;
               }
               return fast;
           }
       } 
       return nullptr;
    }
};
```

## **哈希表**

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int slen = s.size(), tlen = t.size();
        if(slen != tlen) return false;
        unordered_map<char, int> map;
        for(int i = 0; i < slen; i++){
            map[s[i]]--;
        }
        for(int i = 0; i < tlen; i++){
            map[t[i]]++;
            if(map[t[i]] > 0)
                return false;
        }
        return true;
    }
};
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int>map;
        if(!magazine.size() || !ransomNote.size()) return magazine == magazine;
        for(int i = 0; i < magazine.size(); i++){
            map[magazine[i]] --;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            map[ransomNote[i]]++;
            if(map[ransomNote[i]] > 0) return false;
        }
        return true;
    }
};

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int hash[26] = {0};
        for(int i = 0; i < magazine.size(); i++){
            hash[magazine[i] - 'a']++;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            hash[ransomNote[i] - 'a']--;
            if(hash[ransomNote[i]- 'a']<0) return false;
        }
        return true;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```c++
//对于每个单词进行类型
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        //key value  标准 特定数组
        unordered_map<string, vector<string>>map;
        for(auto &str : strs){
            string key = str;
            sort(key.begin(), key.end());
            map[key].emplace_back(str);
        }
        vector<vector<string>>res;
        for(auto x :map){
            res.emplace_back(x.second);
        }
        return res;
    }
};
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```c++
//滑动窗口
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        //维护一个不变的固定滑动窗口
        vector<int>res;
        int slen = s.size(), plen = p.size();
        if(slen < plen) return res;
        vector<int>scnt(26); vector<int>pcnt(26);
        for(int i = 0; i < plen; i++){//首字母那部分
            scnt[s[i] - 'a']++;
            pcnt[p[i] - 'a']++;
        } 
        if(scnt == pcnt) res.emplace_back(0);
        for(int i = 0; i < slen - plen ; i ++){//从i+1开始匹配
            scnt[s[i] - 'a']--;//scnt[s[i - 1] - 'a']--;
            scnt[s[i + plen] - 'a']++;//scnt[s[i + plen - 1] - 'a'] ++;
            if(scnt == pcnt) res.emplace_back(i+1);
        }
        return res;
    }
};
```

### [1002. 查找共用字符!!!](https://leetcode.cn/problems/find-common-characters/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4JNjbm2r32XZEeuDbjIlx8JSBZlR7t2ExYKUCbuL24CiajLtykPxeVib81CcbXdVZAKXjj25sbQU4Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<string>res;
        if(!words.size()) return res;
        vector<int> hash(26);//字符频率
        //单个字符在所有字符串中出现次数的最小值
        vector<int> min_cnt(26, INT_MAX); 
        for(auto x:words){
            fill(hash.begin(), hash.end(), 0);
            for(char y :x){
                hash[y - 'a']++;
            }
            for(int i = 0; i < 26; i++){
                min_cnt[i] = min(min_cnt[i], hash[i]);
                cout<<min_cnt[i]<<" ";
            }
        }
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < min_cnt[i]; j ++){
                //string s(1, i + 'a'); // char -> string
                //result.push_back(s);
                res.emplace_back(1, i + 'a');// char -> string
            }
        }
        return res;
    }
};
```

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv683KTkPTQQiadqOUIy62lID6pvNOGqqpAIVWvj5ibXo0xmsqicP2icaFKQ9Lic2SCD5XWfWrZ0ACaaEpw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//unordered_set底层实现为hash，故set内不会出现重复元素
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果 vector 不能去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

```c++
class Solution {
public:
    int get_next(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {//快慢指针的形式!!!
        //跑的人一步的意思
        int slow = n;
        int fast = get_next(n);
        while(fast != 1 && slow != fast){//什么时候会在循环。
                slow = get_next(slow);
                fast = get_next(get_next(fast));
        }
        return fast == 1;
    }
};

class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = gesum(n);
            if(sum == 1) return true;
            if(set.find(sum) != set.end()) return false; //找到了
            else set.insert(sum);
            n = sum;
        }
    }
    int gesum(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
};
```

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        //find 是找key 是键值
        unordered_map<int, int> res;
        for(int i = 0; i < nums.size(); i++){
            auto index = res.find(target - nums[i]);
            if(index != res.end())
                return {i, index->second};
           res.insert(pair<int,int>(nums[i], i)); 
        }
        return {};
    }
};
```

### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        //为什么能有如此聪明的想法
        //分组+哈希
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int>map;
        if(!magazine.size() || !ransomNote.size()) return magazine == magazine;
        for(int i = 0; i < magazine.size(); i++){
            map[magazine[i]] --;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            map[ransomNote[i]]++;
            if(map[ransomNote[i]] > 0) return false;
        }
        return true;
    }
};

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int hash[26] = {0};
        for(int i = 0; i < magazine.size(); i++){
            hash[magazine[i] - 'a']++;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            hash[ransomNote[i] - 'a']--;
            if(hash[ransomNote[i]- 'a']<0) return false;
        }
        return true;
    }
};
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>>res;
        sort(nums.begin(), nums.end());
        //找出a+b+c=0
        for(int i = 0; i < nums.size(); i++){
            // 去重
            if(i > 0 && nums[i] == nums[i - 1])
                continue;
            
            int left = i + 1, right = nums.size() - 1;
            while(left < right){
                if(nums[i] + nums[left] + nums[right] > 0) 
                    right--;
                else if(nums[i] + nums[right] + nums[left] < 0)
                    left ++;
                else{
                    res.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    while(left <right && nums[left] == nums[left + 1]) left++;
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
};
```

### [18. 四数之和](https://leetcode.cn/problems/4sum/)

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for(int k = 0 ; k < nums.size(); k++){
            if(k >0 && nums[k] == nums[k - 1])
                continue;
//四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target                
            for(int i = k + 1; i < nums.size(); i++){
                if(i > k + 1 && nums[i] == nums[i - 1])
                    continue;
                
                int left = i + 1, right = nums.size() -1 ;
                while(left < right){
                    if(nums[i] + nums[k]  > target - nums[left] -nums[right])
                        right--;
                    else if(nums[i] + nums[k]< target - nums[left] - nums[right])
                        left++;
                    else{
                        res.emplace_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 去重
                        while(left<right && nums[right] == nums[right-1]) right--;
                        while(left<right && nums[left] == nums[left+1]) left++;
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
```

## **字符串**

### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i < s.size(); i += 2*k){
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if(i + k <= s.size()-1){//这个判断语句很精髓
                reverse(s.begin()+i, s.begin()+i+k);
                continue;
            }
             // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
            reverse(s.begin()+i, s.end());
        }
        return s;
    }
};
```

### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```c++
blic:
//很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作
    string replaceSpace(string s) {
         int count = 0;
         for(int i = 0; i < s.size(); i++)
            if(s[i] == ' ')
                count ++;
        int sOldsize = s.size();
        s.resize(sOldsize + count * 2);
        int sNewsize = s.size();

        for(int i = sNewsize-1, j = sOldsize-1; j < i; j--, i--){
            if(s[j] != ' ')
                s[i] = s[j];
            else{
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;

    }
};

class Solution {
public:
    string replaceSpaces(string &str) {
    string res;
    for(auto x : str){
        if(x == ' ')
            res += "%20";
        else res += x;
    }
    return res;
    }
};
```

### [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```c++
class Solution {
public:
    string reverseWords(string s) {
        string str;
        for(int i = s.size()-1; i >=0; i--){
            if(s[i] != ' '){
                str += " ";//新的单词
                string temp;
                while(i >= 0 && s[i] != ' '){
                    temp = s[i] + temp;
                    i--;
                }
                str += temp;
            }
        }
        cout << str <<endl;
        str.erase(str.begin());
        return str;
    }
};

class Solution {
public:
    string reverseWords(string s) {
        string str;
        for(int i = s.size()-1; i>=0; i--){
            int len = 0;
            while(i >= 0 && s[i] != ' ') {
                i--;
                len++;
            }
            if(len) str += s.substr(i + 1, len) + ' ';
        }
        str.erase(str.end()-1);
        return str;
    }
};
```

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5GoB1ibeXZv6ppZs6UlVGO4j4LObJKLlPgXq6Q1qy9HicD36hBB1zxCDhXgvWsKcSJDKejTxqcJ4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c++
class Solution {
public:
    //先局部反转再 整体反转
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin()+n);
        cout<<s<<endl;
        reverse(s.begin()+n, s.end());
        cout<<s<<endl;
        reverse(s.begin(),s.end());
        return s;
    }
};
```

### [28. KMP-实现 strStr()](https://leetcode.cn/problems/implement-strstr/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDic7g5NzCsxYSy974dBcuAyLsxxRYEk1jkrvQPTOpcavwwmjvhKWVIcQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDdWZicTlr0uVCtTmNvPL1hGTwsjR04PvmOdydkbaxr8YblehvQLBOR4Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4cqbtUic3WTC42LtVwqELPDzOrhXshr1UeRTvQY0vnHxnSicQZpFnSazWB6z4Xb0kHwGV4lnibahxGA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
//模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
//next[i] = j 包括i之前最长相等的前后缀长度 是j
//初始化 前缀表统一减一的一种实现  next[0] = j = -1;
    void get_nest(int *next, const string& s){
        //初始化
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++){
            while(j >=0 && s[i] != s[j + 1])
                j = next[j];//向前回退
            if(s[i] == s[j + 1])//找到了相同的前后缀
                j ++;
            next[i] = j;//
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;

        int next[needle.size()];
        get_nest(next, needle);

        int j = -1;
        for(int i = 0; i < haystack.size(); i ++){
            while(j >= 0 && haystack[i] != needle[j +1])
                j = next[j];
            if(haystack[i] == needle[j + 1])
                j++;
            if(j == needle.size() - 1)
                return i - needle.size() + 1; 
        }
        return -1;
    }
};
```

### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

```c++
//数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。
//最长相同前后缀的长度 j+1(next[len - 1] + 1)
class Solution {
public:
    void get_next(int* next, const string& s){
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++){
            while(j >= 0 && s[i] != s[j + 1])
                j = next[j];
            if(s[i] == s[j + 1])
                j++;
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int next[s.size()];
        get_next(next, s);
        for(auto x: next)
            cout<< x << " "; 
        int len = s.size();
 //如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。
        if(next[len - 1] + 1 != 0 && len % (len - (next[len - 1] + 1)) == 0)
            return true;
        return false;
    }
};
```

## **栈与队列**

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

 <img src="https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6aibicu5XmjicWcqwgbrRCXhdaZSGo4vRmW4Tnhmma5Z6Cicpmk47Am1ht1uf8qAxaDHbU5eOjVIfdRg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:67%;" />

```c++
class MyQueue {
public:
    stack<int> stk, cache;
    MyQueue() {

    }
    //将一个栈弹出压入另一个栈中
    void convert(stack<int> &a, stack<int>& b){
        while(!a.empty()){
            b.emplace(a.top());
            a.pop();
        }
    }
    void push(int x) {
        stk.emplace(x);
    }
    
    int pop() {
        convert(stk, cache);
        int res = cache.top();//全部转移一下  取最后那个元素
        cache.pop();
        convert(cache, stk);//然后复原回去原来的状态
        return res;
    }
    
    int peek() {
        //取最先进入stk的元素  也就是转移以后的第一个
        convert(stk, cache);
        int res = cache.top();
        convert(cache, stk);
        return res;
    }
    
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

<img src="https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv6QYtsghRUccTciaMXjtJDFHib6dxnuIvt6j9OGPpJo9Bib7Rh67lCANhpykcDQ9aVdp4GbGAvhnHMwA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:67%;" />

```c++
class MyStack {
public:
    MyStack() {

    }
    queue<int> que, cache;
    void push(int x) {
        que.emplace(x);
    }
    
    int pop() {
        //将que所有元素取出来 留下最后一个元素
        int qsize = que.size();
        for(int i = 0; i < qsize - 1; i++){
            cache.emplace(que.front());
            que.pop();
        }

        int res = que.front();//留下最后一个元素是要返回的值
        que.pop();
        
        que = cache; // 再将que赋值给cache

        while(!cache.empty()){// 清空cache
            cache.pop();
        }
        return res;
    }
    
    int top() {
        return que.back();
    }
    
    bool empty() {
        return que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<int> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
};
```

### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4TwPPDSV1UsA1mNCS595kT4e4iaicribnMyr5icq28rxDVTKJaDKiawacicPBwdQP1cFXLjN9cODdpVPVQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for(auto ch:s){
            if(res.empty() || res.back() != ch)
                res.push_back(ch);
            else res.pop_back();
        }
        return res;
    }
};
```

### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4mCxur8W49qtZmumwtiax6RxExibQQUD4byjhqjr42XrV2K5zRFiaoRf2KBhdFpMPibx8PQuLzOamiaQA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                int num1 = st.top();
                st.pop();
                int num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoi(tokens[i]));
            }
        }
        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
```

### [239. 单调队列-滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv4mCxur8W49qtZmumwtiax6R0axb2Svoib5fzy1ibMlLRFslLlq9TSG84soSCoicvH5jmlQUpKwHiaXZ6A/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

```c++
//单调队列
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int>res;
        deque<int>q;
        for(int i = 0; i < nums.size(); i++){
            while(q.size() && i - q.front() >= k)
                q.pop_front();//头出列
            while(q.size() && nums[q.back()] < nums[i])
                q.pop_back();//一直踢人 保持维护队列单调性 和首元素最大
            q.push_back(i);
//枚举到第k-1个元素后，每次枚举一个新的i都要找一次答案
            if(i >= k - 1)//取队头作为窗口最大元素
                res.push_back(nums[q.front()]);
        }
        return res;
    }
}
//优先队列
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>>que;
        for(int i = 0; i < k; i++){
            que.emplace(nums[i], i);
        }
        vector<int> res = {que.top().first};
        for(int i = k; i < nums.size(); i++){
            que.emplace(nums[i],i);
//这个值的位置出现在滑动窗口左边界的左侧 不在滑动窗口
            while(que.top().second <= i - k)
                que.pop();
            res.emplace_back(que.top().first);
        }
        return res;
    }
};
```

### [135. 最大子序和 - AcWing题库](https://www.acwing.com/problem/content/description/137/)

```c++
#include <iostream>
#include <cstring>
#include<climits>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 3e5 + 10;
int n, m;
LL s[N], que[N];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &s[i]), s[i] += s[i - 1];

    LL res = INT_MIN;
    int hh = 1, tt = 1; que[1] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        while (hh <= tt && i - que[hh] > m) hh ++ ;
        res = max(res, s[i] - s[que[hh]]);
        while (hh <= tt && s[que[tt]] >= s[i]) tt -- ;
        que[ ++ tt] = i;
    }
    printf("%lld\n", res);
    return 0;
}
```

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int>map;
        for(int i = 0; i < nums.size(); i++){
            map[nums[i]]++;
        }
        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), [](const pair<int, int>& a, const pair<int, int>& b) {return a.second > b.second;});
        
        vector<int>res;
        for(int i = 0; i < k; i++){
            res.push_back(vec[i].first);
        }
        return res;
    }
};
//优先队列
class Solution {
public:
    static bool cmp(pair<int, int>& m, pair<int, int>& n) {
        return m.second > n.second;
    }
    // struct myComparison{
    //     bool operator()(pair<int,int>&p1,pair<int,int>&p2){
    //         return p1.second>p2.second;//小顶堆是大于号
    //     }
    // };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>map;//两个int分别是元素和出现的次数
        for(auto& c:nums){
            map[c]++;
        }
// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp); 
// priority_queue<pair<int,int>,vector<pair<int,int>>,myComparison> q; 
        for(auto& a:map){
            q.push(a);
            if(q.size()>k){
               q.pop(); 
            }
        }
        //将结果导出
        vector<int>res;
        while(!q.empty()){
            res.emplace_back(q.top().first);
            q.pop();
        }
        return res;
    }
};
```

## **回溯法**

```c++
**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### [77. 组合](https://leetcode.cn/problems/combinations/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5SBsnFmqibXvBHKstibeks0YUzF9lMF5Zt4ZZ4RibVpeWkYWgB8yR5clS77Ds6lXzIQAbtTicaicSBwfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
class Solution {
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
 //搜索起点有上界 后面无意义
//搜索起点的上界(最大起点) + 接下来要选择的元素个数 - 1 = n
//i + (k - path.size()) - 1 = n
        for (int i = startIndex; i <= n; i++) {   //横 n的范围
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归	//纵 i+1
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6vKujia98Cyl8icF4GEOLJxQ1htrhHXMRicN3S2U3ClLGAia2X7g5nFdZNAFGec8gJ5kP0K7S6bCmung/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    // targetSum：目标和，也就是题目中的n。
    // k：题目中要求k个数的集合。
    // sum：已经收集的元素的总和，也就是path里元素的总和。
    // startIndex：下一层for循环搜索的起始位置。
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        if (path.size() == k) {
            if (sum == targetSum) result.push_back(path);
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        for (int i = startIndex; i <= 9; i++) {
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) { 
        backtracking(n, k, 0, 1);
        return result;
    }
};
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4g9ialwsB98zmuWnyLlpiaohoHHDTWSd9h1PQ9ibjVtIlibWldpCleITDILBVEGeuEruaa3KYU1K96tg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
class Solution {
private:
        unordered_map<char, string> phoneMap{
            {'0', ""},
            {'1', ""},
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };
public:
    vector<string>res;
    string path;
    void backtracking(string &digits, int index){
        if(index == digits.size()){
            res.emplace_back(path);
            return;
        }
        string lettres = phoneMap[digits[index]]; // 取数字对应的字符集
        for(int i = 0; i< lettres.size(); i++){
            path.push_back(lettres[i]);
            backtracking(digits, index+1);// 递归，注意index+1，一下层要处理下一个数字了
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(!digits.size()) return res;
        backtracking(digits, 0);
        return res;
    }
};
```

### 小结

```c++
for循环横向遍历，递归纵向遍历，回溯不断调整结果集
剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6p9Y0KMzgELlibLy2weiauuDDlNKe1gt6tq0r2C1ichf344s3ZHMIYfLyMiaOic6EaBM3jXiaptNNyMEWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
/*
本题还需要startIndex来控制for循环的起始位置
对于组合问题，什么时候需要startIndex呢？
#如果是一个集合来求组合的话，就需要startIndex
#如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex
But
#如果是排列问题，又是另一套分析的套路
*/
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }
        /*
        //搞清楚从哪里面选(循环)
        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = Index; i < candidates.size() && sum + candidates[i] <= target; i++) {
        */
        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            // 不用i+1了，表示可以重复读取当前的数
            //组合没有数量要求
            //元素可无限重复选取
            backtracking(candidates, target, sum, i); 
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) { 
        
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv48aCU4UTGAaibHh1UFayia1yBvRvuXqu2Z4jnaY2fEhUoL3Ggr0zxN7vgzKBRHO7QmeBy5BO1BqeFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
本题candidates 中的每个数字在每个组合中只能使用一次。
本题数组candidates的元素是有重复的，而39.组合总和是无重复元素的数组candidates
本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合

所谓去重，其实就是使用过的元素不能重复选取
元素在同一个组合内是可以重复的,但两个组合不能相同
-->要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重
-->(树层去重的话，需要对数组排序)
*/
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            backtracking(candidates, target, sum, i + 1, used); 
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false); 
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv752l07A1icibBf67wY0GN5cOWDabGLaaOOJKXX23gIU966mkvzD94MOl6TAUAvuCl509osqRRbpfYw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
1.切割问题，有不同的切割方式
2.判断回文
切割问题类似组合问题
组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。
*/
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) { 
        backtracking(s, 0);
        return result;
    }
};
```

### [93. !!!!!复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6mT5fLDGWGROx8nmCACI1veyyNRst5JoiclawgZesPZWNO9H195g9kRFICHpvw9gMVyXqoNMltnXQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    /* // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
        段位以0为开头的数字不合法
        段位里有非正整数字符不合法
        段位如果大于255了不合法
        */
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 不能含有前导0
                return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
    vector<string> result;// 记录结果
    //需要一个变量pointNum，记录添加逗点的数量
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {//切割字符[startIndex,i]
            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
                pointNum++;
                //插入逗点之后下一个子串的起始位置为i+2
                backtracking(s, i + 2, pointNum);  
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            } else break; // 不合法，直接结束本层循环
        }
    }
public:
    vector<string> restoreIpAddresses(string s) { 
        if (s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv7icZnSOhUqwR4ibqNP3nHyktNROmSHwzzNwsWCBrtBH5tHuhg5YKSPl77r8OiapekZ77Dn8NchSoMBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
/*
剩余集合为空的时候，就是叶子节点。
什么时候剩余集合为空呢？
就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了
其实startIndex >= nums.size()，本层for循环本来也结束了
*/ 
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size())// 终止条件可以不加//要遍历整颗树
            return;
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);//每次递归的下一层就是从i+1开始
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) { 
        backtracking(nums, 0);
        return result;
    }
};
```

### 小结

```c++
1.startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？
    如果是一个集合来求组合的话，就需要startIndex，例如：求组合问题！求组合总和！。
	如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：电话号码的字母组合
2.在求和问题中，排序之后加剪枝是常见的套路！
3.集合元素有重复,但要求不能包含重复组合
    “树枝去重”和“树层去重”
used[i - 1] == true，说明同一树支candidates[i - 1]使用过
4.切割问题
切割问题其实类似组合问题
如何模拟那些切割线
切割问题中递归如何终止
在递归循环中如何截取子串
如何判断回文 
```

### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv7DVmb1oGvLmtT7kUX5Hpmog1oKibxeeMV24Dy0UoFibor0wXU62S83iaJvoXpK8IHs9wlwWSCHam2WQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

```c++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;//去重
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    } 
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { 
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
////////////////////////////////////////////////////////////////////////////////////
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        unordered_set<int> uset;		//使用set去重
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1, used);
            path.pop_back();
        }
    } 
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { 
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
```

### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6l713AIoE6ma6iaLd08CPvG6r5BqZHEZZ0PjgiaTPjejfXDtOJibnJThZXsicYM7JGian7GoU24qMltibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```c++
//本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了
//适用于快速查找的
//终止条件  本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和求子集问题！一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归
///////////////////////////遍历树上所有的点和满足特定条件结束的区别

class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        //这里要遍历整个树,取树上节点
        if (path.size() > 1) {
            result.push_back(path);
            // 注意这里不要加return，要取树上的节点
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i < nums.size(); i++) {
            //维持path的递增和不重复
            if ((!path.empty() && nums[i] < path.back())
                    || uset.find(nums[i]) != uset.end()) {
                    continue;
            }
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) { 
        backtracking(nums, 0);
        return result;
    }
};
```

